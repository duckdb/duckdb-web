---
layout: docu
title: List Functions
---

<!-- markdownlint-disable MD001 -->

<!-- Start of section generated by scripts/generate_sql_function_docs.py; categories: [list] -->
<!-- markdownlint-disable MD056 -->

| Function | Description |
|:--|:-------|
| [`list[index]`](#listindex) | Extracts a single list element using a (1-based) index. |
| [`list[begin[:end][:step]]`](#listbeginendstep) | Extract a sublist using [slice conventions]({% link docs/preview/sql/functions/list.md %}#slicing). Negative values are accepted. See [slicing]({% link docs/preview/sql/functions/list.md %}#slicing). |
| [`list1 && list2`](#list1-&&-list2) | Returns true if the lists have any element in common. NULLs are ignored. |
| [`list1 <-> list2`](#list1-<->-list2) | Computes the distance between two lists. |
| [`list1 <=> list2`](#list1-<=>-list2) | Computes the cosine distance between two lists. |
| [`list1 <@ list2`](#list1-<-list2) | Returns true if all elements of l2 are in l1. NULLs are ignored. |
| [`list1 @> list2`](#list1->-list2) | Returns true if all elements of l2 are in l1. NULLs are ignored. |
| [`arg1 || arg2`](#arg1--arg2) | Concatenates two strings, lists, or blobs. Any `NULL` input results in `NULL`. See also [`concat(arg1, arg2, ...)`](#concatvalue-) and [`list_concat(list1, list2)`]({% link docs/preview/sql/functions/list.md %}#list_concatlist1-list2). |
| [`aggregate(list, function_name, ...)`](#aggregatelist-function_name-) | Executes the aggregate function `function_name` on the elements of `list`. See the List Aggregates section for more details. |
| [`apply(list, lambda(x))`](#applylist-lambdax) | Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function. See [`list_transform` examples]({% link docs/preview/sql/functions/lambda.md %}#list_transform-examples). |
| [`array_aggr(list, function_name, ...)`](#array_aggrlist-function_name-) | Executes the aggregate function `function_name` on the elements of `list`. See the List Aggregates section for more details. |
| [`array_aggregate(list, function_name, ...)`](#array_aggregatelist-function_name-) | Executes the aggregate function `function_name` on the elements of `list`. See the List Aggregates section for more details. |
| [`array_apply(list, lambda(x))`](#array_applylist-lambdax) | Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function. See [`list_transform` examples]({% link docs/preview/sql/functions/lambda.md %}#list_transform-examples). |
| [`array_cat()`](#array_cat) | Concatenates two lists. |
| [`array_concat()`](#array_concat) | Concatenates two lists. |
| [`array_contains(list, element)`](#array_containslist-element) | Returns true if the list contains the element. |
| [`array_distinct(list)`](#array_distinctlist) | Removes all duplicates and NULLs from a list. Does not preserve the original order. |
| [`array_extract(list, index)`](#array_extractlist-index) | Extracts the `index`th (1-based) value from the `list`. |
| [`array_filter(list, lambda(x))`](#array_filterlist-lambdax) | Constructs a list from those elements of the input `list` for which the `lambda` function returns `true`. DuckDB must be able to cast the `lambda` function's return type to `BOOL`. The return type of `list_filter` is the same as the input list's. See [`list_filter` examples]({% link docs/preview/sql/functions/lambda.md %}#list_filter-examples). |
| [`array_grade_up(list[, col1][, col2])`](#array_grade_uplist-col1-col2) | Returns the index of their sorted position. |
| [`array_has(list, element)`](#array_haslist-element) | Returns true if the list contains the element. |
| [`array_has_all(list1, list2)`](#array_has_alllist1-list2) | Returns true if all elements of l2 are in l1. NULLs are ignored. |
| [`array_has_any(list1, list2)`](#array_has_anylist1-list2) | Returns true if the lists have any element in common. NULLs are ignored. |
| [`array_indexof(list, element)`](#array_indexoflist-element) | Returns the index of the element if the list contains the element. If the element is not found, it returns NULL. |
| [`array_length(list)`](#array_lengthlist) | Returns the length of the `list`. |
| [`array_length(list, dimension)`](#array_lengthlist-dimension) | `array_length` for lists with dimensions other than 1 not implemented |
| [`array_position(list, element)`](#array_positionlist-element) | Returns the index of the element if the list contains the element. If the element is not found, it returns NULL. |
| [`array_reduce(list, lambda(x,y)[, initial_value])`](#array_reducelist-lambdaxy-initial_value) | Reduces all elements of the input `list` into a single scalar value by executing the `lambda` function on a running result and the next list element. The `lambda` function has an optional `initial_value` argument. See [`list_reduce` examples]({% link docs/preview/sql/functions/lambda.md %}#list_reduce-examples). |
| [`array_resize(list, size[[, value]])`](#array_resizelist-size-value) | Resizes the list to contain size elements. Initializes new elements with value or NULL if value is not set. |
| [`array_reverse_sort(list[, col1])`](#array_reverse_sortlist-col1) | Sorts the elements of the list in reverse order. See the Sorting Lists section for more details about the `NULL` sorting order. |
| [`array_select(value_list, index_list)`](#array_selectvalue_list-index_list) | Returns a list based on the elements selected by the index_list. |
| [`array_slice(list, begin, end)`](#array_slicelist-begin-end) | Extracts a sublist or substring using [slice conventions]({% link docs/preview/sql/functions/list.md %}#slicing). Negative values are accepted. |
| [`array_slice(list, begin, end, step)`](#array_slicelist-begin-end-step) | list_slice with added step feature. |
| [`array_sort(list[, col1][, col2])`](#array_sortlist-col1-col2) | Sorts the elements of the list. See the Sorting Lists section for more details about the `NULL` sorting order. |
| [`array_transform(list, lambda(x))`](#array_transformlist-lambdax) | Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function. See [`list_transform` examples]({% link docs/preview/sql/functions/lambda.md %}#list_transform-examples). |
| [`array_unique(list)`](#array_uniquelist) | Counts the unique elements of a list. |
| [`array_where(value_list, mask_list)`](#array_wherevalue_list-mask_list) | Returns a list with the BOOLEANs in mask_list applied as a mask to the value_list. |
| [`array_zip(, ...)`](#array_zip-) | Zips k LISTs to a new LIST whose length will be that of the longest list. Its elements are structs of k elements from each list list_1, …, list_k, missing elements are replaced with NULL. If truncate is set, all lists are truncated to the smallest list length. |
| [`char_length(list)`](#char_lengthlist) | Returns the length of the `list`. |
| [`character_length(list)`](#character_lengthlist) | Returns the length of the `list`. |
| [`concat(value, ...)`](#concatvalue-) | Concatenates multiple strings, lists, or blobs. `NULL` inputs are skipped. See also [operator `||`](#arg1--arg2). |
| [`contains(list, element)`](#containslist-element) | Returns `true` if the `list` contains the `element`. |
| [`filter(list, lambda(x))`](#filterlist-lambdax) | Constructs a list from those elements of the input `list` for which the `lambda` function returns `true`. DuckDB must be able to cast the `lambda` function's return type to `BOOL`. The return type of `list_filter` is the same as the input list's. See [`list_filter` examples]({% link docs/preview/sql/functions/lambda.md %}#list_filter-examples). |
| [`flatten(nested_list)`](#flattennested_list) | [Flattens](#flattening) a nested list by one level. |
| [`generate_series(start[, stop][, step])`](#generate_seriesstart-stop-step) | Creates a list of values between `start` and `stop` - the stop parameter is inclusive. |
| [`grade_up(list[, col1][, col2])`](#grade_uplist-col1-col2) | Returns the index of their sorted position. |
| [`len(list)`](#lenlist) | Returns the length of the `list`. |
| [`length(list)`](#lengthlist) | Returns the length of the `list`. |
| [`list_aggr(list, function_name, ...)`](#list_aggrlist-function_name-) | Executes the aggregate function `function_name` on the elements of `list`. See the List Aggregates section for more details. |
| [`list_aggregate(list, function_name, ...)`](#list_aggregatelist-function_name-) | Executes the aggregate function `function_name` on the elements of `list`. See the List Aggregates section for more details. |
| [`list_apply(list, lambda(x))`](#list_applylist-lambdax) | Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function. See [`list_transform` examples]({% link docs/preview/sql/functions/lambda.md %}#list_transform-examples). |
| [`list_cat()`](#list_cat) | Concatenates two lists. |
| [`list_concat()`](#list_concat) | Concatenates two lists. |
| [`list_contains(list, element)`](#list_containslist-element) | Returns true if the list contains the element. |
| [`list_cosine_distance(list1, list2)`](#list_cosine_distancelist1-list2) | Computes the cosine distance between two lists. |
| [`list_cosine_similarity(list1, list2)`](#list_cosine_similaritylist1-list2) | Computes the cosine similarity between two lists. |
| [`list_distance(list1, list2)`](#list_distancelist1-list2) | Computes the distance between two lists. |
| [`list_distinct(list)`](#list_distinctlist) | Removes all duplicates and NULLs from a list. Does not preserve the original order. |
| [`list_dot_product(list1, list2)`](#list_dot_productlist1-list2) | Computes the inner product between two lists. |
| [`list_element(list, index)`](#list_elementlist-index) | Extract the indexth (1-based) value from the list. |
| [`list_extract(list, index)`](#list_extractlist-index) | Extract the indexth (1-based) value from the list. |
| [`list_filter(list, lambda(x))`](#list_filterlist-lambdax) | Constructs a list from those elements of the input `list` for which the `lambda` function returns `true`. DuckDB must be able to cast the `lambda` function's return type to `BOOL`. The return type of `list_filter` is the same as the input list's. See [`list_filter` examples]({% link docs/preview/sql/functions/lambda.md %}#list_filter-examples). |
| [`list_grade_up(list[, col1][, col2])`](#list_grade_uplist-col1-col2) | Returns the index of their sorted position. |
| [`list_has(list, element)`](#list_haslist-element) | Returns true if the list contains the element. |
| [`list_has_all(list1, list2)`](#list_has_alllist1-list2) | Returns true if all elements of l2 are in l1. NULLs are ignored. |
| [`list_has_any(list1, list2)`](#list_has_anylist1-list2) | Returns true if the lists have any element in common. NULLs are ignored. |
| [`list_indexof(list, element)`](#list_indexoflist-element) | Returns the index of the element if the list contains the element. If the element is not found, it returns NULL. |
| [`list_inner_product(list1, list2)`](#list_inner_productlist1-list2) | Computes the inner product between two lists. |
| [`list_negative_dot_product(list1, list2)`](#list_negative_dot_productlist1-list2) | Computes the negative inner product between two lists. |
| [`list_negative_inner_product(list1, list2)`](#list_negative_inner_productlist1-list2) | Computes the negative inner product between two lists. |
| [`list_pack(, ...)`](#list_pack-) | Creates a LIST containing the argument values. |
| [`list_position(list, element)`](#list_positionlist-element) | Returns the index of the element if the list contains the element. If the element is not found, it returns NULL. |
| [`list_reduce(list, lambda(x,y)[, initial_value])`](#list_reducelist-lambdaxy-initial_value) | Reduces all elements of the input `list` into a single scalar value by executing the `lambda` function on a running result and the next list element. The `lambda` function has an optional `initial_value` argument. See [`list_reduce` examples]({% link docs/preview/sql/functions/lambda.md %}#list_reduce-examples). |
| [`list_resize(list, size[[, value]])`](#list_resizelist-size-value) | Resizes the list to contain size elements. Initializes new elements with value or NULL if value is not set. |
| [`list_reverse_sort(list[, col1])`](#list_reverse_sortlist-col1) | Sorts the elements of the list in reverse order. See the Sorting Lists section for more details about the `NULL` sorting order. |
| [`list_select(value_list, index_list)`](#list_selectvalue_list-index_list) | Returns a list based on the elements selected by the index_list. |
| [`list_slice(list, begin, end)`](#list_slicelist-begin-end) | Extracts a sublist or substring using [slice conventions]({% link docs/preview/sql/functions/list.md %}#slicing). Negative values are accepted. |
| [`list_slice(list, begin, end, step)`](#list_slicelist-begin-end-step) | list_slice with added step feature. |
| [`list_sort(list[, col1][, col2])`](#list_sortlist-col1-col2) | Sorts the elements of the list. See the Sorting Lists section for more details about the `NULL` sorting order. |
| [`list_transform(list, lambda(x))`](#list_transformlist-lambdax) | Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function. See [`list_transform` examples]({% link docs/preview/sql/functions/lambda.md %}#list_transform-examples). |
| [`list_unique(list)`](#list_uniquelist) | Counts the unique elements of a list. |
| [`list_value(, ...)`](#list_value-) | Creates a LIST containing the argument values. |
| [`list_where(value_list, mask_list)`](#list_wherevalue_list-mask_list) | Returns a list with the BOOLEANs in mask_list applied as a mask to the value_list. |
| [`list_zip(, ...)`](#list_zip-) | Zips k LISTs to a new LIST whose length will be that of the longest list. Its elements are structs of k elements from each list list_1, …, list_k, missing elements are replaced with NULL. If truncate is set, all lists are truncated to the smallest list length. |
| [`range(start[, stop][, step])`](#rangestart-stop-step) | Creates a list of values between `start` and `stop` - the stop parameter is exclusive. |
| [`reduce(list, lambda(x,y)[, initial_value])`](#reducelist-lambdaxy-initial_value) | Reduces all elements of the input `list` into a single scalar value by executing the `lambda` function on a running result and the next list element. The `lambda` function has an optional `initial_value` argument. See [`list_reduce` examples]({% link docs/preview/sql/functions/lambda.md %}#list_reduce-examples). |
| [`repeat(list, count)`](#repeatlist-count) | Repeats the `list` `count` number of times. |
| [`unnest(list)`](#unnestlist) | Unnests a list by one level. Note that this is a special function that alters the cardinality of the result. See the [unnest page]({% link docs/preview/sql/query_syntax/unnest.md %}) for more details. |
| [`unpivot_list(, ...)`](#unpivot_list-) | Identical to list_value, but generated as part of unpivot for better error messages. |

<!-- markdownlint-enable MD056 -->

#### `list[index]`

<div class="nostroke_table"></div>

| **Description** | Extracts a single list element using a (1-based) index. |
| **Example** | `[4, 5, 6][3]`{:.language-sql .highlight} |
| **Result** | `6` |
| **Alias** | `list_extract` |

#### `list[begin[:end][:step]]`

<div class="nostroke_table"></div>

| **Description** | Extract a sublist using [slice conventions]({% link docs/preview/sql/functions/list.md %}#slicing). Negative values are accepted. See [slicing]({% link docs/preview/sql/functions/list.md %}#slicing). |
| **Example** | `[4, 5, 6][3]`{:.language-sql .highlight} |
| **Result** | `6` |
| **Alias** | `list_slice` |

#### `list1 && list2`

<div class="nostroke_table"></div>

| **Description** | Returns true if the lists have any element in common. NULLs are ignored. |
| **Example** | `list_has_any([1, 2, 3], [2, 3, 4])`{:.language-sql .highlight} |
| **Result** | `true` |
| **Aliases** | `array_has_any`, `list_has_any` |

#### `list1 <-> list2`

<div class="nostroke_table"></div>

| **Description** | Computes the distance between two lists. |
| **Example** | `list_distance([1, 2, 3], [1, 2, 3])`{:.language-sql .highlight} |
| **Result** | `0.0` |
| **Alias** | `list_distance` |

#### `list1 <=> list2`

<div class="nostroke_table"></div>

| **Description** | Computes the cosine distance between two lists. |
| **Example** | `list_cosine_distance([1, 2, 3], [1, 2, 3])`{:.language-sql .highlight} |
| **Result** | `0.0` |
| **Alias** | `list_cosine_distance` |

#### `list1 <@ list2`

<div class="nostroke_table"></div>

| **Description** | Returns true if all elements of l2 are in l1. NULLs are ignored. |
| **Example** | `list_has_all([1, 2, 3], [2, 3])`{:.language-sql .highlight} |
| **Result** | `true` |
| **Aliases** | `@>`, `array_has_all`, `list_has_all` |

#### `list1 @> list2`

<div class="nostroke_table"></div>

| **Description** | Returns true if all elements of l2 are in l1. NULLs are ignored. |
| **Example** | `list_has_all([1, 2, 3], [2, 3])`{:.language-sql .highlight} |
| **Result** | `true` |
| **Aliases** | `<@`, `array_has_all`, `list_has_all` |

#### `arg1 || arg2`

<div class="nostroke_table"></div>

| **Description** | Concatenates two strings, lists, or blobs. Any `NULL` input results in `NULL`. See also [`concat(arg1, arg2, ...)`](#concatvalue-) and [`list_concat(list1, list2)`]({% link docs/preview/sql/functions/list.md %}#list_concatlist1-list2). |
| **Example 1** | `'Duck' || 'DB'`{:.language-sql .highlight} |
| **Result** | `DuckDB` |
| **Example 2** | `[1, 2, 3] || [4, 5, 6]`{:.language-sql .highlight} |
| **Result** | `[1, 2, 3, 4, 5, 6]` |
| **Example 3** | `'\xAA'::BLOB || '\xBB'::BLOB`{:.language-sql .highlight} |
| **Result** | `\xAA\xBB` |

#### `aggregate(list, function_name, ...)`

<div class="nostroke_table"></div>

| **Description** | Executes the aggregate function `function_name` on the elements of `list`. See the List Aggregates section for more details. |
| **Example** | `aggregate([1, 2, NULL], 'min')`{:.language-sql .highlight} |
| **Result** | `1` |
| **Aliases** | `array_aggr`, `array_aggregate`, `list_aggr`, `list_aggregate` |

#### `apply(list, lambda(x))`

<div class="nostroke_table"></div>

| **Description** | Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function. See [`list_transform` examples]({% link docs/preview/sql/functions/lambda.md %}#list_transform-examples). |
| **Example** | `apply([1, 2, 3], lambda x : x + 1)`{:.language-sql .highlight} |
| **Result** | `[2, 3, 4]` |
| **Aliases** | `array_apply`, `array_transform`, `list_apply`, `list_transform` |

#### `array_aggr(list, function_name, ...)`

<div class="nostroke_table"></div>

| **Description** | Executes the aggregate function `function_name` on the elements of `list`. See the List Aggregates section for more details. |
| **Example** | `array_aggr([1, 2, NULL], 'min')`{:.language-sql .highlight} |
| **Result** | `1` |
| **Aliases** | `aggregate`, `array_aggregate`, `list_aggr`, `list_aggregate` |

#### `array_aggregate(list, function_name, ...)`

<div class="nostroke_table"></div>

| **Description** | Executes the aggregate function `function_name` on the elements of `list`. See the List Aggregates section for more details. |
| **Example** | `array_aggregate([1, 2, NULL], 'min')`{:.language-sql .highlight} |
| **Result** | `1` |
| **Aliases** | `aggregate`, `array_aggr`, `list_aggr`, `list_aggregate` |

#### `array_apply(list, lambda(x))`

<div class="nostroke_table"></div>

| **Description** | Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function. See [`list_transform` examples]({% link docs/preview/sql/functions/lambda.md %}#list_transform-examples). |
| **Example** | `array_apply([1, 2, 3], lambda x : x + 1)`{:.language-sql .highlight} |
| **Result** | `[2, 3, 4]` |
| **Aliases** | `apply`, `array_transform`, `list_apply`, `list_transform` |

#### `array_cat()`

<div class="nostroke_table"></div>

| **Description** | Concatenates two lists. |
| **Example** | `array_cat([2, 3], [4, 5, 6])`{:.language-sql .highlight} |
| **Result** | `[2, 3, 4, 5, 6]` |
| **Aliases** | `array_concat`, `list_cat`, `list_concat` |

#### `array_concat()`

<div class="nostroke_table"></div>

| **Description** | Concatenates two lists. |
| **Example** | `array_concat([2, 3], [4, 5, 6])`{:.language-sql .highlight} |
| **Result** | `[2, 3, 4, 5, 6]` |
| **Aliases** | `array_cat`, `list_cat`, `list_concat` |

#### `array_contains(list, element)`

<div class="nostroke_table"></div>

| **Description** | Returns true if the list contains the element. |
| **Example** | `array_contains([1, 2, NULL], 1)`{:.language-sql .highlight} |
| **Result** | `true` |
| **Aliases** | `array_has`, `list_contains`, `list_has` |

#### `array_distinct(list)`

<div class="nostroke_table"></div>

| **Description** | Removes all duplicates and NULLs from a list. Does not preserve the original order. |
| **Example** | `array_distinct([1, 1, NULL, -3, 1, 5])`{:.language-sql .highlight} |
| **Result** | `[5, -3, 1]` |
| **Alias** | `list_distinct` |

#### `array_extract(list, index)`

<div class="nostroke_table"></div>

| **Description** | Extracts the `index`th (1-based) value from the `list`. |
| **Example** | `array_extract([4, 5, 6], 3)`{:.language-sql .highlight} |
| **Result** | `6` |

#### `array_filter(list, lambda(x))`

<div class="nostroke_table"></div>

| **Description** | Constructs a list from those elements of the input `list` for which the `lambda` function returns `true`. DuckDB must be able to cast the `lambda` function's return type to `BOOL`. The return type of `list_filter` is the same as the input list's. See [`list_filter` examples]({% link docs/preview/sql/functions/lambda.md %}#list_filter-examples). |
| **Example** | `array_filter([3, 4, 5], lambda x : x > 4)`{:.language-sql .highlight} |
| **Result** | `[5]` |
| **Aliases** | `filter`, `list_filter` |

#### `array_grade_up(list[, col1][, col2])`

<div class="nostroke_table"></div>

| **Description** | Returns the index of their sorted position. |
| **Example** | `array_grade_up([3, 6, 1, 2])`{:.language-sql .highlight} |
| **Result** | `[3, 4, 1, 2]` |
| **Aliases** | `grade_up`, `list_grade_up` |

#### `array_has(list, element)`

<div class="nostroke_table"></div>

| **Description** | Returns true if the list contains the element. |
| **Example** | `array_has([1, 2, NULL], 1)`{:.language-sql .highlight} |
| **Result** | `true` |
| **Aliases** | `array_contains`, `list_contains`, `list_has` |

#### `array_has_all(list1, list2)`

<div class="nostroke_table"></div>

| **Description** | Returns true if all elements of l2 are in l1. NULLs are ignored. |
| **Example** | `array_has_all([1, 2, 3], [2, 3])`{:.language-sql .highlight} |
| **Result** | `true` |
| **Aliases** | `<@`, `@>`, `list_has_all` |

#### `array_has_any(list1, list2)`

<div class="nostroke_table"></div>

| **Description** | Returns true if the lists have any element in common. NULLs are ignored. |
| **Example** | `array_has_any([1, 2, 3], [2, 3, 4])`{:.language-sql .highlight} |
| **Result** | `true` |
| **Aliases** | `&&`, `list_has_any` |

#### `array_indexof(list, element)`

<div class="nostroke_table"></div>

| **Description** | Returns the index of the element if the list contains the element. If the element is not found, it returns NULL. |
| **Example** | `array_indexof([1, 2, NULL], 2)`{:.language-sql .highlight} |
| **Result** | `2` |
| **Aliases** | `array_position`, `list_indexof`, `list_position` |

#### `array_length(list)`

<div class="nostroke_table"></div>

| **Description** | Returns the length of the `list`. |
| **Example** | `array_length([1, 2, 3])`{:.language-sql .highlight} |
| **Result** | `3` |

#### `array_length(list, dimension)`

<div class="nostroke_table"></div>

| **Description** | `array_length` for lists with dimensions other than 1 not implemented |
| **Example** | `array_length([1, 2, 3])`{:.language-sql .highlight} |
| **Result** | `3` |

#### `array_position(list, element)`

<div class="nostroke_table"></div>

| **Description** | Returns the index of the element if the list contains the element. If the element is not found, it returns NULL. |
| **Example** | `array_position([1, 2, NULL], 2)`{:.language-sql .highlight} |
| **Result** | `2` |
| **Aliases** | `array_indexof`, `list_indexof`, `list_position` |

#### `array_reduce(list, lambda(x,y)[, initial_value])`

<div class="nostroke_table"></div>

| **Description** | Reduces all elements of the input `list` into a single scalar value by executing the `lambda` function on a running result and the next list element. The `lambda` function has an optional `initial_value` argument. See [`list_reduce` examples]({% link docs/preview/sql/functions/lambda.md %}#list_reduce-examples). |
| **Example** | `array_reduce([1, 2, 3], lambda x, y : x + y)`{:.language-sql .highlight} |
| **Result** | `6` |
| **Aliases** | `list_reduce`, `reduce` |

#### `array_resize(list, size[[, value]])`

<div class="nostroke_table"></div>

| **Description** | Resizes the list to contain size elements. Initializes new elements with value or NULL if value is not set. |
| **Example** | `array_resize([1, 2, 3], 5, 0)`{:.language-sql .highlight} |
| **Result** | `[1, 2, 3, 0, 0]` |
| **Alias** | `list_resize` |

#### `array_reverse_sort(list[, col1])`

<div class="nostroke_table"></div>

| **Description** | Sorts the elements of the list in reverse order. See the Sorting Lists section for more details about the `NULL` sorting order. |
| **Example** | `array_reverse_sort([3, 6, 1, 2])`{:.language-sql .highlight} |
| **Result** | `[6, 3, 2, 1]` |
| **Alias** | `list_reverse_sort` |

#### `array_select(value_list, index_list)`

<div class="nostroke_table"></div>

| **Description** | Returns a list based on the elements selected by the index_list. |
| **Example** | `array_select([10, 20, 30, 40], [1, 4])`{:.language-sql .highlight} |
| **Result** | `[10, 40]` |
| **Alias** | `list_select` |

#### `array_slice(list, begin, end)`

<div class="nostroke_table"></div>

| **Description** | Extracts a sublist or substring using [slice conventions]({% link docs/preview/sql/functions/list.md %}#slicing). Negative values are accepted. |
| **Example 1** | `array_slice('DuckDB', 3, 4)`{:.language-sql .highlight} |
| **Result** | `ck` |
| **Example 2** | `array_slice('DuckDB', 3, NULL)`{:.language-sql .highlight} |
| **Result** | `NULL` |
| **Example 3** | `array_slice('DuckDB', 0, -3)`{:.language-sql .highlight} |
| **Result** | `Duck` |
| **Alias** | `list_slice` |

#### `array_slice(list, begin, end, step)`

<div class="nostroke_table"></div>

| **Description** | list_slice with added step feature. |
| **Example** | `array_slice([4, 5, 6], 1, 3, 2)`{:.language-sql .highlight} |
| **Result** | `[4, 6]` |
| **Alias** | `list_slice` |

#### `array_sort(list[, col1][, col2])`

<div class="nostroke_table"></div>

| **Description** | Sorts the elements of the list. See the Sorting Lists section for more details about the `NULL` sorting order. |
| **Example** | `array_sort([3, 6, 1, 2])`{:.language-sql .highlight} |
| **Result** | `[1, 2, 3, 6]` |
| **Alias** | `list_sort` |

#### `array_transform(list, lambda(x))`

<div class="nostroke_table"></div>

| **Description** | Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function. See [`list_transform` examples]({% link docs/preview/sql/functions/lambda.md %}#list_transform-examples). |
| **Example** | `array_transform([1, 2, 3], lambda x : x + 1)`{:.language-sql .highlight} |
| **Result** | `[2, 3, 4]` |
| **Aliases** | `apply`, `array_apply`, `list_apply`, `list_transform` |

#### `array_unique(list)`

<div class="nostroke_table"></div>

| **Description** | Counts the unique elements of a list. |
| **Example** | `array_unique([1, 1, NULL, -3, 1, 5])`{:.language-sql .highlight} |
| **Result** | `3` |
| **Alias** | `list_unique` |

#### `array_where(value_list, mask_list)`

<div class="nostroke_table"></div>

| **Description** | Returns a list with the BOOLEANs in mask_list applied as a mask to the value_list. |
| **Example** | `array_where([10, 20, 30, 40], [true, false, false, true])`{:.language-sql .highlight} |
| **Result** | `[10, 40]` |
| **Alias** | `list_where` |

#### `array_zip(, ...)`

<div class="nostroke_table"></div>

| **Description** | Zips k LISTs to a new LIST whose length will be that of the longest list. Its elements are structs of k elements from each list list_1, …, list_k, missing elements are replaced with NULL. If truncate is set, all lists are truncated to the smallest list length. |
| **Example** | `array_zip([1, 2], [3, 4], [5, 6])`{:.language-sql .highlight} |
| **Result** | `[(1, 3, 5), (2, 4, 6)]` |
| **Alias** | `list_zip` |

#### `char_length(list)`

<div class="nostroke_table"></div>

| **Description** | Returns the length of the `list`. |
| **Example** | `char_length([1,2,3])`{:.language-sql .highlight} |
| **Result** | `3` |
| **Aliases** | `character_length`, `len`, `length` |

#### `character_length(list)`

<div class="nostroke_table"></div>

| **Description** | Returns the length of the `list`. |
| **Example** | `character_length([1,2,3])`{:.language-sql .highlight} |
| **Result** | `3` |
| **Aliases** | `char_length`, `len`, `length` |

#### `concat(value, ...)`

<div class="nostroke_table"></div>

| **Description** | Concatenates multiple strings, lists, or blobs. `NULL` inputs are skipped. See also [operator `||`](#arg1--arg2). |
| **Example** | `concat('Hello', ' ', 'World')`{:.language-sql .highlight} |
| **Result** | `Hello World` |

#### `contains(list, element)`

<div class="nostroke_table"></div>

| **Description** | Returns `true` if the `list` contains the `element`. |
| **Example** | `contains([1, 2, NULL], 1)`{:.language-sql .highlight} |
| **Result** | `true` |

#### `filter(list, lambda(x))`

<div class="nostroke_table"></div>

| **Description** | Constructs a list from those elements of the input `list` for which the `lambda` function returns `true`. DuckDB must be able to cast the `lambda` function's return type to `BOOL`. The return type of `list_filter` is the same as the input list's. See [`list_filter` examples]({% link docs/preview/sql/functions/lambda.md %}#list_filter-examples). |
| **Example** | `filter([3, 4, 5], lambda x : x > 4)`{:.language-sql .highlight} |
| **Result** | `[5]` |
| **Aliases** | `array_filter`, `list_filter` |

#### `flatten(nested_list)`

<div class="nostroke_table"></div>

| **Description** | [Flattens](#flattening) a nested list by one level. |
| **Example** | `flatten([[1, 2, 3], [4, 5]])`{:.language-sql .highlight} |
| **Result** | `[1, 2, 3, 4, 5]` |

#### `generate_series(start[, stop][, step])`

<div class="nostroke_table"></div>

| **Description** | Creates a list of values between `start` and `stop` - the stop parameter is inclusive. |
| **Example** | `generate_series(2, 5, 3)`{:.language-sql .highlight} |
| **Result** | `[2, 5]` |

#### `grade_up(list[, col1][, col2])`

<div class="nostroke_table"></div>

| **Description** | Returns the index of their sorted position. |
| **Example** | `grade_up([3, 6, 1, 2])`{:.language-sql .highlight} |
| **Result** | `[3, 4, 1, 2]` |
| **Aliases** | `array_grade_up`, `list_grade_up` |

#### `len(list)`

<div class="nostroke_table"></div>

| **Description** | Returns the length of the `list`. |
| **Example** | `length([1,2,3])`{:.language-sql .highlight} |
| **Result** | `3` |
| **Aliases** | `char_length`, `character_length`, `length` |

#### `length(list)`

<div class="nostroke_table"></div>

| **Description** | Returns the length of the `list`. |
| **Example** | `length([1,2,3])`{:.language-sql .highlight} |
| **Result** | `3` |
| **Aliases** | `char_length`, `character_length`, `len` |

#### `list_aggr(list, function_name, ...)`

<div class="nostroke_table"></div>

| **Description** | Executes the aggregate function `function_name` on the elements of `list`. See the List Aggregates section for more details. |
| **Example** | `list_aggregate([1, 2, NULL], 'min')`{:.language-sql .highlight} |
| **Result** | `1` |
| **Aliases** | `aggregate`, `array_aggr`, `array_aggregate`, `list_aggregate` |

#### `list_aggregate(list, function_name, ...)`

<div class="nostroke_table"></div>

| **Description** | Executes the aggregate function `function_name` on the elements of `list`. See the List Aggregates section for more details. |
| **Example** | `list_aggregate([1, 2, NULL], 'min')`{:.language-sql .highlight} |
| **Result** | `1` |
| **Aliases** | `aggregate`, `array_aggr`, `array_aggregate`, `list_aggr` |

#### `list_apply(list, lambda(x))`

<div class="nostroke_table"></div>

| **Description** | Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function. See [`list_transform` examples]({% link docs/preview/sql/functions/lambda.md %}#list_transform-examples). |
| **Example** | `list_apply([1, 2, 3], lambda x : x + 1)`{:.language-sql .highlight} |
| **Result** | `[2, 3, 4]` |
| **Aliases** | `apply`, `array_apply`, `array_transform`, `list_transform` |

#### `list_cat()`

<div class="nostroke_table"></div>

| **Description** | Concatenates two lists. |
| **Example** | `list_cat([2, 3], [4, 5, 6])`{:.language-sql .highlight} |
| **Result** | `[2, 3, 4, 5, 6]` |
| **Aliases** | `array_cat`, `array_concat`, `list_concat` |

#### `list_concat()`

<div class="nostroke_table"></div>

| **Description** | Concatenates two lists. |
| **Example** | `list_concat([2, 3], [4, 5, 6])`{:.language-sql .highlight} |
| **Result** | `[2, 3, 4, 5, 6]` |
| **Aliases** | `array_cat`, `array_concat`, `list_cat` |

#### `list_contains(list, element)`

<div class="nostroke_table"></div>

| **Description** | Returns true if the list contains the element. |
| **Example** | `list_contains([1, 2, NULL], 1)`{:.language-sql .highlight} |
| **Result** | `true` |
| **Aliases** | `array_contains`, `array_has`, `list_has` |

#### `list_cosine_distance(list1, list2)`

<div class="nostroke_table"></div>

| **Description** | Computes the cosine distance between two lists. |
| **Example** | `list_cosine_distance([1, 2, 3], [1, 2, 3])`{:.language-sql .highlight} |
| **Result** | `0.0` |
| **Alias** | `<=>` |

#### `list_cosine_similarity(list1, list2)`

<div class="nostroke_table"></div>

| **Description** | Computes the cosine similarity between two lists. |
| **Example** | `list_cosine_similarity([1, 2, 3], [1, 2, 3])`{:.language-sql .highlight} |
| **Result** | `1.0` |

#### `list_distance(list1, list2)`

<div class="nostroke_table"></div>

| **Description** | Computes the distance between two lists. |
| **Example** | `list_distance([1, 2, 3], [1, 2, 3])`{:.language-sql .highlight} |
| **Result** | `0.0` |
| **Alias** | `<->` |

#### `list_distinct(list)`

<div class="nostroke_table"></div>

| **Description** | Removes all duplicates and NULLs from a list. Does not preserve the original order. |
| **Example** | `list_distinct([1, 1, NULL, -3, 1, 5])`{:.language-sql .highlight} |
| **Result** | `[5, -3, 1]` |
| **Alias** | `array_distinct` |

#### `list_dot_product(list1, list2)`

<div class="nostroke_table"></div>

| **Description** | Computes the inner product between two lists. |
| **Example** | `list_dot_product([1, 2, 3], [1, 2, 3])`{:.language-sql .highlight} |
| **Result** | `14.0` |
| **Alias** | `list_inner_product` |

#### `list_element(list, index)`

<div class="nostroke_table"></div>

| **Description** | Extract the indexth (1-based) value from the list. |
| **Example** | `list_element([4, 5, 6], 3)`{:.language-sql .highlight} |
| **Result** | `6` |
| **Alias** | `list_extract` |

#### `list_extract(list, index)`

<div class="nostroke_table"></div>

| **Description** | Extract the indexth (1-based) value from the list. |
| **Example** | `list_extract([4, 5, 6], 3)`{:.language-sql .highlight} |
| **Result** | `6` |
| **Alias** | `list_element` |

#### `list_filter(list, lambda(x))`

<div class="nostroke_table"></div>

| **Description** | Constructs a list from those elements of the input `list` for which the `lambda` function returns `true`. DuckDB must be able to cast the `lambda` function's return type to `BOOL`. The return type of `list_filter` is the same as the input list's. See [`list_filter` examples]({% link docs/preview/sql/functions/lambda.md %}#list_filter-examples). |
| **Example** | `list_filter([3, 4, 5], lambda x : x > 4)`{:.language-sql .highlight} |
| **Result** | `[5]` |
| **Aliases** | `array_filter`, `filter` |

#### `list_grade_up(list[, col1][, col2])`

<div class="nostroke_table"></div>

| **Description** | Returns the index of their sorted position. |
| **Example** | `list_grade_up([3, 6, 1, 2])`{:.language-sql .highlight} |
| **Result** | `[3, 4, 1, 2]` |
| **Aliases** | `array_grade_up`, `grade_up` |

#### `list_has(list, element)`

<div class="nostroke_table"></div>

| **Description** | Returns true if the list contains the element. |
| **Example** | `list_has([1, 2, NULL], 1)`{:.language-sql .highlight} |
| **Result** | `true` |
| **Aliases** | `array_contains`, `array_has`, `list_contains` |

#### `list_has_all(list1, list2)`

<div class="nostroke_table"></div>

| **Description** | Returns true if all elements of l2 are in l1. NULLs are ignored. |
| **Example** | `list_has_all([1, 2, 3], [2, 3])`{:.language-sql .highlight} |
| **Result** | `true` |
| **Aliases** | `<@`, `@>`, `array_has_all` |

#### `list_has_any(list1, list2)`

<div class="nostroke_table"></div>

| **Description** | Returns true if the lists have any element in common. NULLs are ignored. |
| **Example** | `list_has_any([1, 2, 3], [2, 3, 4])`{:.language-sql .highlight} |
| **Result** | `true` |
| **Aliases** | `&&`, `array_has_any` |

#### `list_indexof(list, element)`

<div class="nostroke_table"></div>

| **Description** | Returns the index of the element if the list contains the element. If the element is not found, it returns NULL. |
| **Example** | `list_indexof([1, 2, NULL], 2)`{:.language-sql .highlight} |
| **Result** | `2` |
| **Aliases** | `array_indexof`, `array_position`, `list_position` |

#### `list_inner_product(list1, list2)`

<div class="nostroke_table"></div>

| **Description** | Computes the inner product between two lists. |
| **Example** | `list_inner_product([1, 2, 3], [1, 2, 3])`{:.language-sql .highlight} |
| **Result** | `14.0` |
| **Alias** | `list_dot_product` |

#### `list_negative_dot_product(list1, list2)`

<div class="nostroke_table"></div>

| **Description** | Computes the negative inner product between two lists. |
| **Example** | `list_negative_dot_product([1, 2, 3], [1, 2, 3])`{:.language-sql .highlight} |
| **Result** | `-14.0` |
| **Alias** | `list_negative_inner_product` |

#### `list_negative_inner_product(list1, list2)`

<div class="nostroke_table"></div>

| **Description** | Computes the negative inner product between two lists. |
| **Example** | `list_negative_inner_product([1, 2, 3], [1, 2, 3])`{:.language-sql .highlight} |
| **Result** | `-14.0` |
| **Alias** | `list_negative_dot_product` |

#### `list_pack(, ...)`

<div class="nostroke_table"></div>

| **Description** | Creates a LIST containing the argument values. |
| **Example** | `list_pack(4, 5, 6)`{:.language-sql .highlight} |
| **Result** | `[4, 5, 6]` |
| **Alias** | `list_value` |

#### `list_position(list, element)`

<div class="nostroke_table"></div>

| **Description** | Returns the index of the element if the list contains the element. If the element is not found, it returns NULL. |
| **Example** | `list_position([1, 2, NULL], 2)`{:.language-sql .highlight} |
| **Result** | `2` |
| **Aliases** | `array_indexof`, `array_position`, `list_indexof` |

#### `list_reduce(list, lambda(x,y)[, initial_value])`

<div class="nostroke_table"></div>

| **Description** | Reduces all elements of the input `list` into a single scalar value by executing the `lambda` function on a running result and the next list element. The `lambda` function has an optional `initial_value` argument. See [`list_reduce` examples]({% link docs/preview/sql/functions/lambda.md %}#list_reduce-examples). |
| **Example** | `list_reduce([1, 2, 3], lambda x, y : x + y)`{:.language-sql .highlight} |
| **Result** | `6` |
| **Aliases** | `array_reduce`, `reduce` |

#### `list_resize(list, size[[, value]])`

<div class="nostroke_table"></div>

| **Description** | Resizes the list to contain size elements. Initializes new elements with value or NULL if value is not set. |
| **Example** | `list_resize([1, 2, 3], 5, 0)`{:.language-sql .highlight} |
| **Result** | `[1, 2, 3, 0, 0]` |
| **Alias** | `array_resize` |

#### `list_reverse_sort(list[, col1])`

<div class="nostroke_table"></div>

| **Description** | Sorts the elements of the list in reverse order. See the Sorting Lists section for more details about the `NULL` sorting order. |
| **Example** | `list_reverse_sort([3, 6, 1, 2])`{:.language-sql .highlight} |
| **Result** | `[6, 3, 2, 1]` |
| **Alias** | `array_reverse_sort` |

#### `list_select(value_list, index_list)`

<div class="nostroke_table"></div>

| **Description** | Returns a list based on the elements selected by the index_list. |
| **Example** | `list_select([10, 20, 30, 40], [1, 4])`{:.language-sql .highlight} |
| **Result** | `[10, 40]` |
| **Alias** | `array_select` |

#### `list_slice(list, begin, end)`

<div class="nostroke_table"></div>

| **Description** | Extracts a sublist or substring using [slice conventions]({% link docs/preview/sql/functions/list.md %}#slicing). Negative values are accepted. |
| **Example** | `list_slice([4, 5, 6], 2, 3)`{:.language-sql .highlight} |
| **Result** | `[5, 6]` |
| **Alias** | `array_slice` |

#### `list_slice(list, begin, end, step)`

<div class="nostroke_table"></div>

| **Description** | list_slice with added step feature. |
| **Example** | `list_slice([4, 5, 6], 1, 3, 2)`{:.language-sql .highlight} |
| **Result** | `[4, 6]` |
| **Alias** | `array_slice` |

#### `list_sort(list[, col1][, col2])`

<div class="nostroke_table"></div>

| **Description** | Sorts the elements of the list. See the Sorting Lists section for more details about the `NULL` sorting order. |
| **Example** | `list_sort([3, 6, 1, 2])`{:.language-sql .highlight} |
| **Result** | `[1, 2, 3, 6]` |
| **Alias** | `array_sort` |

#### `list_transform(list, lambda(x))`

<div class="nostroke_table"></div>

| **Description** | Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function. See [`list_transform` examples]({% link docs/preview/sql/functions/lambda.md %}#list_transform-examples). |
| **Example** | `list_transform([1, 2, 3], lambda x : x + 1)`{:.language-sql .highlight} |
| **Result** | `[2, 3, 4]` |
| **Aliases** | `apply`, `array_apply`, `array_transform`, `list_apply` |

#### `list_unique(list)`

<div class="nostroke_table"></div>

| **Description** | Counts the unique elements of a list. |
| **Example** | `list_unique([1, 1, NULL, -3, 1, 5])`{:.language-sql .highlight} |
| **Result** | `3` |
| **Alias** | `array_unique` |

#### `list_value(, ...)`

<div class="nostroke_table"></div>

| **Description** | Creates a LIST containing the argument values. |
| **Example** | `list_value(4, 5, 6)`{:.language-sql .highlight} |
| **Result** | `[4, 5, 6]` |
| **Alias** | `list_pack` |

#### `list_where(value_list, mask_list)`

<div class="nostroke_table"></div>

| **Description** | Returns a list with the BOOLEANs in mask_list applied as a mask to the value_list. |
| **Example** | `list_where([10, 20, 30, 40], [true, false, false, true])`{:.language-sql .highlight} |
| **Result** | `[10, 40]` |
| **Alias** | `array_where` |

#### `list_zip(, ...)`

<div class="nostroke_table"></div>

| **Description** | Zips k LISTs to a new LIST whose length will be that of the longest list. Its elements are structs of k elements from each list list_1, …, list_k, missing elements are replaced with NULL. If truncate is set, all lists are truncated to the smallest list length. |
| **Example** | `list_zip([1, 2], [3, 4], [5, 6])`{:.language-sql .highlight} |
| **Result** | `[(1, 3, 5), (2, 4, 6)]` |
| **Alias** | `array_zip` |

#### `range(start[, stop][, step])`

<div class="nostroke_table"></div>

| **Description** | Creates a list of values between `start` and `stop` - the stop parameter is exclusive. |
| **Example** | `range(2, 5, 3)`{:.language-sql .highlight} |
| **Result** | `[2]` |

#### `reduce(list, lambda(x,y)[, initial_value])`

<div class="nostroke_table"></div>

| **Description** | Reduces all elements of the input `list` into a single scalar value by executing the `lambda` function on a running result and the next list element. The `lambda` function has an optional `initial_value` argument. See [`list_reduce` examples]({% link docs/preview/sql/functions/lambda.md %}#list_reduce-examples). |
| **Example** | `reduce([1, 2, 3], lambda x, y : x + y)`{:.language-sql .highlight} |
| **Result** | `6` |
| **Aliases** | `array_reduce`, `list_reduce` |

#### `repeat(list, count)`

<div class="nostroke_table"></div>

| **Description** | Repeats the `list` `count` number of times. |
| **Example** | `repeat([1, 2, 3], 5)`{:.language-sql .highlight} |
| **Result** | `[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]` |

#### `unnest(list)`

<div class="nostroke_table"></div>

| **Description** | Unnests a list by one level. Note that this is a special function that alters the cardinality of the result. See the [unnest page]({% link docs/preview/sql/query_syntax/unnest.md %}) for more details. |
| **Example** | `unnest([1, 2, 3])`{:.language-sql .highlight} |
| **Result** | Multiple rows: `'1'`, `'2'`, `'3'` |

#### `unpivot_list(, ...)`

<div class="nostroke_table"></div>

| **Description** | Identical to list_value, but generated as part of unpivot for better error messages. |
| **Example** | `unpivot_list(4, 5, 6)`{:.language-sql .highlight} |
| **Result** | `[4, 5, 6]` |

<!-- End of section generated by scripts/generate_sql_function_docs.py -->


## List Operators

The following operators are supported for lists:

<!-- markdownlint-disable MD056 -->

| Operator | Description | Example | Result |
|-|--|---|-|
| `&&`  | Alias for [`list_has_any`](#list_has_anylist1-list2).                                                                   | `[1, 2, 3, 4, 5] && [2, 5, 5, 6]` | `true`               |
| `@>`  | Alias for [`list_has_all`](#list_has_alllist-sub-list), where the list on the **right** of the operator is the sublist. | `[1, 2, 3, 4] @> [3, 4, 3]`       | `true`               |
| `<@`  | Alias for [`list_has_all`](#list_has_alllist-sub-list), where the list on the **left** of the operator is the sublist.  | `[1, 4] <@ [1, 2, 3, 4]`          | `true`               |
| `||`  | Similar to [`list_concat`](#list_concatlist1--listn), except any `NULL` input results in `NULL`.                        | `[1, 2, 3] || [4, 5, 6]`          | `[1, 2, 3, 4, 5, 6]` |
| `<=>` | Alias for [`list_cosine_distance`](#list_cosine_distancelist1-list2).                                                   | `[1, 2, 3] <=> [1, 2, 5]`         | `0.007416606`        |
| `<->` | Alias for [`list_distance`](#list_distancelist1-list2).                                                                 | `[1, 2, 3] <-> [1, 2, 5]`         | `2.0`                |

<!-- markdownlint-enable MD056 -->

## List Comprehension

Python-style list comprehension can be used to compute expressions over elements in a list. For example:

```sql
SELECT [lower(x) FOR x IN strings] AS strings
FROM (VALUES (['Hello', '', 'World'])) t(strings);
```

<div class="monospace_table"></div>

|     strings      |
|------------------|
| [hello, , world] |

```sql
SELECT [upper(x) FOR x IN strings IF len(x) > 0] AS strings
FROM (VALUES (['Hello', '', 'World'])) t(strings);
```

<div class="monospace_table"></div>

|    strings     |
|----------------|
| [HELLO, WORLD] |

List comprehensions can also use the position of the list elements by adding a second variable.
In the following example, we use `x, i`, where `x` is the value and `i` is the position:

```sql
SELECT [4, 5, 6] AS l, [x FOR x, i IN l IF i != 2] AS filtered;
```

<div class="monospace_table"></div>

|     l     | filtered |
|-----------|----------|
| [4, 5, 6] | [4, 6]   |

Under the hood, `[f(x) FOR x IN y IF g(x)]` is translated to `list_transform(list_filter(y, x -> f(x)), x -> f(x))`.

## Range Functions

DuckDB offers two range functions, [`range(start, stop, step)`](#range) and [`generate_series(start, stop, step)`](#generate_series), and their variants with default arguments for `stop` and `step`. The two functions' behavior is different regarding their `stop` argument. This is documented below.

### `range`

The `range` function creates a list of values in the range between `start` and `stop`.
The `start` parameter is inclusive, while the `stop` parameter is exclusive.
The default value of `start` is 0 and the default value of `step` is 1.

Based on the number of arguments, the following variants of `range` exist.

#### `range(stop)`

```sql
SELECT range(5);
```

```text
[0, 1, 2, 3, 4]
```

#### `range(start, stop)`

```sql
SELECT range(2, 5);
```

```text
[2, 3, 4]
```

#### `range(start, stop, step)`

```sql
SELECT range(2, 5, 3);
```

```text
[2]
```

### `generate_series`

The `generate_series` function creates a list of values in the range between `start` and `stop`.
Both the `start` and the `stop` parameters are inclusive.
The default value of `start` is 0 and the default value of `step` is 1.
Based on the number of arguments, the following variants of `generate_series` exist.

#### `generate_series(stop)`

```sql
SELECT generate_series(5);
```

```text
[0, 1, 2, 3, 4, 5]
```

#### `generate_series(start, stop)`

```sql
SELECT generate_series(2, 5);
```

```text
[2, 3, 4, 5]
```

#### `generate_series(start, stop, step)`

```sql
SELECT generate_series(2, 5, 3);
```

```text
[2, 5]
```

#### `generate_subscripts(arr, dim)`

The `generate_subscripts(arr, dim)` function generates indexes along the `dim`th dimension of array `arr`.

```sql
SELECT generate_subscripts([4, 5, 6], 1) AS i;
```

| i |
|--:|
| 1 |
| 2 |
| 3 |

### Date Ranges

Date ranges are also supported for `TIMESTAMP` and `TIMESTAMP WITH TIME ZONE` values.
Note that for these types, the `stop` and `step` arguments have to be specified explicitly (a default value is not provided).

#### `range` for Date Ranges

```sql
SELECT *
FROM range(DATE '1992-01-01', DATE '1992-03-01', INTERVAL '1' MONTH);
```

|        range        |
|---------------------|
| 1992-01-01 00:00:00 |
| 1992-02-01 00:00:00 |

#### `generate_series` for Date Ranges

```sql
SELECT *
FROM generate_series(DATE '1992-01-01', DATE '1992-03-01', INTERVAL '1' MONTH);
```

|   generate_series   |
|---------------------|
| 1992-01-01 00:00:00 |
| 1992-02-01 00:00:00 |
| 1992-03-01 00:00:00 |

## Slicing

The function [`list_slice`](#list_slicelist-begin-end) can be used to extract a sublist from a list. The following variants exist:

* `list_slice(list, begin, end)`
* `list_slice(list, begin, end, step)`
* `array_slice(list, begin, end)`
* `array_slice(list, begin, end, step)`
* `list[begin:end]`
* `list[begin:end:step]`

The arguments are as follows:

* `list`
    * Is the list to be sliced
* `begin`
    * Is the index of the first element to be included in the slice
    * When `begin < 0` the index is counted from the end of the list
    * When `begin < 0` and `-begin > length`, `begin` is clamped to the beginning of the list
    * When `begin > length`, the result is an empty list
    * **Bracket Notation:** When `begin` is omitted, it defaults to the beginning of the list
* `end`
    * Is the index of the last element to be included in the slice
    * When `end < 0` the index is counted from the end of the list
    * When `end > length`, end is clamped to `length`
    * When `end < begin`, the result is an empty list
    * **Bracket Notation:** When `end` is omitted, it defaults to the end of the list. When `end` is omitted and a `step` is provided, `end` must be replaced with a `-`
* `step` *(optional)*
    * Is the step size between elements in the slice
    * When `step < 0` the slice is reversed, and `begin` and `end` are swapped
    * Must be non-zero

Examples:

```sql
SELECT list_slice([1, 2, 3, 4, 5], 2, 4);
```

```text
[2, 3, 4]
```

```sql
SELECT ([1, 2, 3, 4, 5])[2:4:2];
```

```text
[2, 4]
```

```sql
SELECT([1, 2, 3, 4, 5])[4:2:-2];
```

```text
[4, 2]
```

```sql
SELECT ([1, 2, 3, 4, 5])[:];
```

```text
[1, 2, 3, 4, 5]
```

```sql
SELECT ([1, 2, 3, 4, 5])[:-:2];
```

```text
[1, 3, 5]
```

```sql
SELECT ([1, 2, 3, 4, 5])[:-:-2];
```

```text
[5, 3, 1]
```

## List Aggregates

The function [`list_aggregate`](#list_aggregatelist-name) allows the execution of arbitrary existing aggregate functions on the elements of a list. Its first argument is the list (column), its second argument is the aggregate function name, e.g., `min`, `histogram` or `sum`.

`list_aggregate` accepts additional arguments after the aggregate function name. These extra arguments are passed directly to the aggregate function, which serves as the second argument of `list_aggregate`.

```sql
SELECT list_aggregate([1, 2, -4, NULL], 'min');
```

```text
-4
```

```sql
SELECT list_aggregate([2, 4, 8, 42], 'sum');
```

```text
56
```

```sql
SELECT list_aggregate([[1, 2], [NULL], [2, 10, 3]], 'last');
```

```text
[2, 10, 3]
```

```sql
SELECT list_aggregate([2, 4, 8, 42], 'string_agg', '|');
```

```text
2|4|8|42
```

### `list_*` Rewrite Functions

The following is a list of existing rewrites. Rewrites simplify the use of the list aggregate function by only taking the list (column) as their argument. `list_avg`, `list_var_samp`, `list_var_pop`, `list_stddev_pop`, `list_stddev_samp`, `list_sem`, `list_approx_count_distinct`, `list_bit_xor`, `list_bit_or`, `list_bit_and`, `list_bool_and`, `list_bool_or`, `list_count`, `list_entropy`, `list_last`, `list_first`, `list_kurtosis`, `list_kurtosis_pop`, `list_min`, `list_max`, `list_product`, `list_skewness`, `list_sum`, `list_string_agg`, `list_mode`, `list_median`, `list_mad` and `list_histogram`.

```sql
SELECT list_min([1, 2, -4, NULL]);
```

```text
-4
```

```sql
SELECT list_sum([2, 4, 8, 42]);
```

```text
56
```

```sql
SELECT list_last([[1, 2], [NULL], [2, 10, 3]]);
```

```text
[2, 10, 3]
```

#### `array_to_string`

Concatenates list/array elements using an optional delimiter.

```sql
SELECT array_to_string([1, 2, 3], '-') AS str;
```

```text
1-2-3
```

This is equivalent to the following SQL:

```sql
SELECT list_aggr([1, 2, 3], 'string_agg', '-') AS str;
```

```text
1-2-3
```

## Sorting Lists

The function `list_sort` sorts the elements of a list either in ascending or descending order.
In addition, it allows to provide whether `NULL` values should be moved to the beginning or to the end of the list.
It has the same sorting behavior as DuckDB's `ORDER BY` clause.
Therefore, (nested) values compare the same in `list_sort` as in `ORDER BY`.

By default, if no modifiers are provided, DuckDB sorts `ASC NULLS FIRST`.
I.e., the values are sorted in ascending order and `NULL` values are placed first.
This is identical to the default sort order of SQLite.
The default sort order can be changed using [`PRAGMA` statements.](../query_syntax/orderby).

`list_sort` leaves it open to the user whether they want to use the default sort order or a custom order.
`list_sort` takes up to two additional optional parameters.
The second parameter provides the sort order and can be either `ASC` or `DESC`.
The third parameter provides the `NULL` order and can be either `NULLS FIRST` or `NULLS LAST`.

This query uses the default sort order and the default `NULL` order.

```sql
SELECT list_sort([1, 3, NULL, 5, NULL, -5]);
```

```sql
[NULL, NULL, -5, 1, 3, 5]
```

This query provides the sort order.
The `NULL` order uses the configurable default value.

```sql
SELECT list_sort([1, 3, NULL, 2], 'ASC');
```

```sql
[NULL, 1, 2, 3]
```

This query provides both the sort order and the `NULL` order.

```sql
SELECT list_sort([1, 3, NULL, 2], 'DESC', 'NULLS FIRST');
```

```sql
[NULL, 3, 2, 1]
```

`list_reverse_sort` has an optional second parameter providing the `NULL` sort order.
It can be either `NULLS FIRST` or `NULLS LAST`.

This query uses the default `NULL` sort order.

```sql
SELECT list_sort([1, 3, NULL, 5, NULL, -5]);
```

```sql
[NULL, NULL, -5, 1, 3, 5]
```

This query provides the `NULL` sort order.

```sql
SELECT list_reverse_sort([1, 3, NULL, 2], 'NULLS LAST');
```

```sql
[3, 2, 1, NULL]
```

## Flattening

The flatten function is a scalar function that converts a list of lists into a single list by concatenating each sub-list together.
Note that this only flattens one level at a time, not all levels of sub-lists.

Convert a list of lists into a single list:

```sql
SELECT
    flatten([
        [1, 2],
        [3, 4]
    ]);
```

```text
[1, 2, 3, 4]
```

If the list has multiple levels of lists, only the first level of sub-lists is concatenated into a single list:

```sql
SELECT
    flatten([
        [
            [1, 2],
            [3, 4],
        ],
        [
            [5, 6],
            [7, 8],
        ]
    ]);
```

```text
[[1, 2], [3, 4], [5, 6], [7, 8]]
```

In general, the input to the flatten function should be a list of lists (not a single level list).
However, the behavior of the flatten function has specific behavior when handling empty lists and `NULL` values.

If the input list is empty, return an empty list:

```sql
SELECT flatten([]);
```

```text
[]
```

If the entire input to flatten is `NULL`, return `NULL`:

```sql
SELECT flatten(NULL);
```

```text
NULL
```

If a list whose only entry is `NULL` is flattened, return an empty list:

```sql
SELECT flatten([NULL]);
```

```text
[]
```

If the sub-list in a list of lists only contains `NULL`, do not modify the sub-list:

```sql
-- (Note the extra set of parentheses vs. the prior example)
SELECT flatten([[NULL]]);
```

```text
[NULL]
```

Even if the only contents of each sub-list is `NULL`, still concatenate them together. Note that no de-duplication occurs when flattening. See `list_distinct` function for de-duplication:

```sql
SELECT flatten([[NULL], [NULL]]);
```

```text
[NULL, NULL]
```

## Lambda Functions

DuckDB supports lambda functions in the form `(parameter1, parameter2, ...) -> expression`.
For details, see the [lambda functions page]({% link docs/preview/sql/functions/lambda.md %}).

## Related Functions

* The [aggregate functions]({% link docs/preview/sql/functions/aggregates.md %}) `list` and `histogram` produce lists and lists of structs.
* The [`unnest` function]({% link docs/preview/sql/query_syntax/unnest.md %}) is used to unnest a list by one level.
