---
layout: docu
title: C API - Complete API
---

## API Reference

<!-- This section is generated by scripts/generate_config_docs.py -->

### `Open/Connect`

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <a href="#duckdb_open"><span class="nf">duckdb_open</span></a>(<span class="kt">const</span> <span class="kt">char</span> *<span class="nv">path</span>, <span class="kt">duckdb_database</span> *<span class="nv">out_database</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_open_ext"><span class="nf">duckdb_open_ext</span></a>(<span class="kt">const</span> <span class="kt">char</span> *<span class="nv">path</span>, <span class="kt">duckdb_database</span> *<span class="nv">out_database</span>, <span class="kt">duckdb_config</span> <span class="nv">config</span>, <span class="kt">char</span> **<span class="nv">out_error</span>);
<span class="kt">void</span> <a href="#duckdb_close"><span class="nf">duckdb_close</span></a>(<span class="kt">duckdb_database</span> *<span class="nv">database</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_connect"><span class="nf">duckdb_connect</span></a>(<span class="kt">duckdb_database</span> <span class="nv">database</span>, <span class="kt">duckdb_connection</span> *<span class="nv">out_connection</span>);
<span class="kt">void</span> <a href="#duckdb_interrupt"><span class="nf">duckdb_interrupt</span></a>(<span class="kt">duckdb_connection</span> <span class="nv">connection</span>);
<span class="nv">duckdb_query_progress_type</span> <a href="#duckdb_query_progress"><span class="nf">duckdb_query_progress</span></a>(<span class="kt">duckdb_connection</span> <span class="nv">connection</span>);
<span class="kt">void</span> <a href="#duckdb_disconnect"><span class="nf">duckdb_disconnect</span></a>(<span class="kt">duckdb_connection</span> *<span class="nv">connection</span>);
<span class="kt">const</span> <span class="kt">char</span> *<a href="#duckdb_library_version"><span class="nf">duckdb_library_version</span></a>();
</code></pre></div></div>

### `Configuration`

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <a href="#duckdb_create_config"><span class="nf">duckdb_create_config</span></a>(<span class="kt">duckdb_config</span> *<span class="nv">out_config</span>);
<span class="kt">size_t</span> <a href="#duckdb_config_count"><span class="nf">duckdb_config_count</span></a>();
<span class="kt">duckdb_state</span> <a href="#duckdb_get_config_flag"><span class="nf">duckdb_get_config_flag</span></a>(<span class="kt">size_t</span> <span class="nv">index</span>, <span class="kt">const</span> <span class="kt">char</span> **<span class="nv">out_name</span>, <span class="kt">const</span> <span class="kt">char</span> **<span class="nv">out_description</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_set_config"><span class="nf">duckdb_set_config</span></a>(<span class="kt">duckdb_config</span> <span class="nv">config</span>, <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">name</span>, <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">option</span>);
<span class="kt">void</span> <a href="#duckdb_destroy_config"><span class="nf">duckdb_destroy_config</span></a>(<span class="kt">duckdb_config</span> *<span class="nv">config</span>);
</code></pre></div></div>

### `Query Execution`

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <a href="#duckdb_query"><span class="nf">duckdb_query</span></a>(<span class="kt">duckdb_connection</span> <span class="nv">connection</span>, <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">query</span>, <span class="kt">duckdb_result</span> *<span class="nv">out_result</span>);
<span class="kt">void</span> <a href="#duckdb_destroy_result"><span class="nf">duckdb_destroy_result</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>);
<span class="kt">const</span> <span class="kt">char</span> *<a href="#duckdb_column_name"><span class="nf">duckdb_column_name</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">col</span>);
<span class="nv">duckdb_type</span> <a href="#duckdb_column_type"><span class="nf">duckdb_column_type</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">col</span>);
<span class="nv">duckdb_statement_type</span> <a href="#duckdb_result_statement_type"><span class="nf">duckdb_result_statement_type</span></a>(<span class="kt">duckdb_result</span> <span class="nv">result</span>);
<span class="kt">duckdb_logical_type</span> <a href="#duckdb_column_logical_type"><span class="nf">duckdb_column_logical_type</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">col</span>);
<span class="kt">idx_t</span> <a href="#duckdb_column_count"><span class="nf">duckdb_column_count</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>);
<span class="kt">idx_t</span> <a href="#duckdb_row_count"><span class="nf">duckdb_row_count</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>);
<span class="kt">idx_t</span> <a href="#duckdb_rows_changed"><span class="nf">duckdb_rows_changed</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>);
<span class="kt">void</span> *<a href="#duckdb_column_data"><span class="nf">duckdb_column_data</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">col</span>);
<span class="kt">bool</span> *<a href="#duckdb_nullmask_data"><span class="nf">duckdb_nullmask_data</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">col</span>);
<span class="kt">const</span> <span class="kt">char</span> *<a href="#duckdb_result_error"><span class="nf">duckdb_result_error</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>);
</code></pre></div></div>

### `Result Functions`

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_data_chunk</span> <a href="#duckdb_result_get_chunk"><span class="nf">duckdb_result_get_chunk</span></a>(<span class="kt">duckdb_result</span> <span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">chunk_index</span>);
<span class="kt">bool</span> <a href="#duckdb_result_is_streaming"><span class="nf">duckdb_result_is_streaming</span></a>(<span class="kt">duckdb_result</span> <span class="nv">result</span>);
<span class="kt">idx_t</span> <a href="#duckdb_result_chunk_count"><span class="nf">duckdb_result_chunk_count</span></a>(<span class="kt">duckdb_result</span> <span class="nv">result</span>);
<span class="nv">duckdb_result_type</span> <a href="#duckdb_result_return_type"><span class="nf">duckdb_result_return_type</span></a>(<span class="kt">duckdb_result</span> <span class="nv">result</span>);
<span class="kt">bool</span> <a href="#duckdb_value_boolean"><span class="nf">duckdb_value_boolean</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">col</span>, <span class="kt">idx_t</span> <span class="nv">row</span>);
<span class="kt">int8_t</span> <a href="#duckdb_value_int8"><span class="nf">duckdb_value_int8</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">col</span>, <span class="kt">idx_t</span> <span class="nv">row</span>);
<span class="kt">int16_t</span> <a href="#duckdb_value_int16"><span class="nf">duckdb_value_int16</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">col</span>, <span class="kt">idx_t</span> <span class="nv">row</span>);
<span class="kt">int32_t</span> <a href="#duckdb_value_int32"><span class="nf">duckdb_value_int32</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">col</span>, <span class="kt">idx_t</span> <span class="nv">row</span>);
<span class="kt">int64_t</span> <a href="#duckdb_value_int64"><span class="nf">duckdb_value_int64</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">col</span>, <span class="kt">idx_t</span> <span class="nv">row</span>);
<span class="kt">duckdb_hugeint</span> <a href="#duckdb_value_hugeint"><span class="nf">duckdb_value_hugeint</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">col</span>, <span class="kt">idx_t</span> <span class="nv">row</span>);
<span class="nv">duckdb_uhugeint</span> <a href="#duckdb_value_uhugeint"><span class="nf">duckdb_value_uhugeint</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">col</span>, <span class="kt">idx_t</span> <span class="nv">row</span>);
<span class="nv">duckdb_decimal</span> <a href="#duckdb_value_decimal"><span class="nf">duckdb_value_decimal</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">col</span>, <span class="kt">idx_t</span> <span class="nv">row</span>);
<span class="kt">uint8_t</span> <a href="#duckdb_value_uint8"><span class="nf">duckdb_value_uint8</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">col</span>, <span class="kt">idx_t</span> <span class="nv">row</span>);
<span class="kt">uint16_t</span> <a href="#duckdb_value_uint16"><span class="nf">duckdb_value_uint16</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">col</span>, <span class="kt">idx_t</span> <span class="nv">row</span>);
<span class="kt">uint32_t</span> <a href="#duckdb_value_uint32"><span class="nf">duckdb_value_uint32</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">col</span>, <span class="kt">idx_t</span> <span class="nv">row</span>);
<span class="kt">uint64_t</span> <a href="#duckdb_value_uint64"><span class="nf">duckdb_value_uint64</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">col</span>, <span class="kt">idx_t</span> <span class="nv">row</span>);
<span class="kt">float</span> <a href="#duckdb_value_float"><span class="nf">duckdb_value_float</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">col</span>, <span class="kt">idx_t</span> <span class="nv">row</span>);
<span class="kt">double</span> <a href="#duckdb_value_double"><span class="nf">duckdb_value_double</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">col</span>, <span class="kt">idx_t</span> <span class="nv">row</span>);
<span class="kt">duckdb_date</span> <a href="#duckdb_value_date"><span class="nf">duckdb_value_date</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">col</span>, <span class="kt">idx_t</span> <span class="nv">row</span>);
<span class="kt">duckdb_time</span> <a href="#duckdb_value_time"><span class="nf">duckdb_value_time</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">col</span>, <span class="kt">idx_t</span> <span class="nv">row</span>);
<span class="kt">duckdb_timestamp</span> <a href="#duckdb_value_timestamp"><span class="nf">duckdb_value_timestamp</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">col</span>, <span class="kt">idx_t</span> <span class="nv">row</span>);
<span class="kt">duckdb_interval</span> <a href="#duckdb_value_interval"><span class="nf">duckdb_value_interval</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">col</span>, <span class="kt">idx_t</span> <span class="nv">row</span>);
<span class="kt">char</span> *<a href="#duckdb_value_varchar"><span class="nf">duckdb_value_varchar</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">col</span>, <span class="kt">idx_t</span> <span class="nv">row</span>);
<span class="kt">char</span> *<a href="#duckdb_value_varchar_internal"><span class="nf">duckdb_value_varchar_internal</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">col</span>, <span class="kt">idx_t</span> <span class="nv">row</span>);
<span class="nv">duckdb_string</span> <a href="#duckdb_value_string_internal"><span class="nf">duckdb_value_string_internal</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">col</span>, <span class="kt">idx_t</span> <span class="nv">row</span>);
<span class="kt">duckdb_blob</span> <a href="#duckdb_value_blob"><span class="nf">duckdb_value_blob</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">col</span>, <span class="kt">idx_t</span> <span class="nv">row</span>);
<span class="kt">bool</span> <a href="#duckdb_value_is_null"><span class="nf">duckdb_value_is_null</span></a>(<span class="kt">duckdb_result</span> *<span class="nv">result</span>, <span class="kt">idx_t</span> <span class="nv">col</span>, <span class="kt">idx_t</span> <span class="nv">row</span>);
</code></pre></div></div>

### `Helpers`

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> *<a href="#duckdb_malloc"><span class="nf">duckdb_malloc</span></a>(<span class="kt">size_t</span> <span class="nv">size</span>);
<span class="kt">void</span> <a href="#duckdb_free"><span class="nf">duckdb_free</span></a>(<span class="kt">void</span> *<span class="nv">ptr</span>);
<span class="kt">idx_t</span> <a href="#duckdb_vector_size"><span class="nf">duckdb_vector_size</span></a>();
<span class="kt">bool</span> <a href="#duckdb_string_is_inlined"><span class="nf">duckdb_string_is_inlined</span></a>(<span class="nv">duckdb_string_t</span> <span class="nv">string</span>);
</code></pre></div></div>

### `Date/Time/Timestamp Helpers`

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_date_struct</span> <a href="#duckdb_from_date"><span class="nf">duckdb_from_date</span></a>(<span class="kt">duckdb_date</span> <span class="nv">date</span>);
<span class="kt">duckdb_date</span> <a href="#duckdb_to_date"><span class="nf">duckdb_to_date</span></a>(<span class="kt">duckdb_date_struct</span> <span class="nv">date</span>);
<span class="kt">bool</span> <a href="#duckdb_is_finite_date"><span class="nf">duckdb_is_finite_date</span></a>(<span class="kt">duckdb_date</span> <span class="nv">date</span>);
<span class="kt">duckdb_time_struct</span> <a href="#duckdb_from_time"><span class="nf">duckdb_from_time</span></a>(<span class="kt">duckdb_time</span> <span class="nv">time</span>);
<span class="kt">duckdb_time</span> <a href="#duckdb_to_time"><span class="nf">duckdb_to_time</span></a>(<span class="kt">duckdb_time_struct</span> <span class="nv">time</span>);
<span class="kt">duckdb_timestamp_struct</span> <a href="#duckdb_from_timestamp"><span class="nf">duckdb_from_timestamp</span></a>(<span class="kt">duckdb_timestamp</span> <span class="nv">ts</span>);
<span class="kt">duckdb_timestamp</span> <a href="#duckdb_to_timestamp"><span class="nf">duckdb_to_timestamp</span></a>(<span class="kt">duckdb_timestamp_struct</span> <span class="nv">ts</span>);
<span class="kt">bool</span> <a href="#duckdb_is_finite_timestamp"><span class="nf">duckdb_is_finite_timestamp</span></a>(<span class="kt">duckdb_timestamp</span> <span class="nv">ts</span>);
</code></pre></div></div>

### `Hugeint Helpers`

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <a href="#duckdb_hugeint_to_double"><span class="nf">duckdb_hugeint_to_double</span></a>(<span class="kt">duckdb_hugeint</span> <span class="nv">val</span>);
<span class="kt">duckdb_hugeint</span> <a href="#duckdb_double_to_hugeint"><span class="nf">duckdb_double_to_hugeint</span></a>(<span class="kt">double</span> <span class="nv">val</span>);
<span class="nv">duckdb_decimal</span> <a href="#duckdb_double_to_decimal"><span class="nf">duckdb_double_to_decimal</span></a>(<span class="kt">double</span> <span class="nv">val</span>, <span class="kt">uint8_t</span> <span class="nv">width</span>, <span class="kt">uint8_t</span> <span class="nv">scale</span>);
</code></pre></div></div>

### `Unsigned Hugeint Helpers`

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <a href="#duckdb_uhugeint_to_double"><span class="nf">duckdb_uhugeint_to_double</span></a>(<span class="nv">duckdb_uhugeint</span> <span class="nv">val</span>);
<span class="nv">duckdb_uhugeint</span> <a href="#duckdb_double_to_uhugeint"><span class="nf">duckdb_double_to_uhugeint</span></a>(<span class="kt">double</span> <span class="nv">val</span>);
</code></pre></div></div>

### `Decimal Helpers`

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <a href="#duckdb_decimal_to_double"><span class="nf">duckdb_decimal_to_double</span></a>(<span class="nv">duckdb_decimal</span> <span class="nv">val</span>);
</code></pre></div></div>

### `Prepared Statements`

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <a href="#duckdb_prepare"><span class="nf">duckdb_prepare</span></a>(<span class="kt">duckdb_connection</span> <span class="nv">connection</span>, <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">query</span>, <span class="kt">duckdb_prepared_statement</span> *<span class="nv">out_prepared_statement</span>);
<span class="kt">void</span> <a href="#duckdb_destroy_prepare"><span class="nf">duckdb_destroy_prepare</span></a>(<span class="kt">duckdb_prepared_statement</span> *<span class="nv">prepared_statement</span>);
<span class="kt">const</span> <span class="kt">char</span> *<a href="#duckdb_prepare_error"><span class="nf">duckdb_prepare_error</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>);
<span class="kt">idx_t</span> <a href="#duckdb_nparams"><span class="nf">duckdb_nparams</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>);
<span class="kt">const</span> <span class="kt">char</span> *<a href="#duckdb_parameter_name"><span class="nf">duckdb_parameter_name</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">idx_t</span> <span class="nv">index</span>);
<span class="nv">duckdb_type</span> <a href="#duckdb_param_type"><span class="nf">duckdb_param_type</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">idx_t</span> <span class="nv">param_idx</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_clear_bindings"><span class="nf">duckdb_clear_bindings</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>);
<span class="nv">duckdb_statement_type</span> <a href="#duckdb_prepared_statement_type"><span class="nf">duckdb_prepared_statement_type</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">statement</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_bind_value"><span class="nf">duckdb_bind_value</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">idx_t</span> <span class="nv">param_idx</span>, <span class="kt">duckdb_value</span> <span class="nv">val</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_bind_parameter_index"><span class="nf">duckdb_bind_parameter_index</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">idx_t</span> *<span class="nv">param_idx_out</span>, <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">name</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_bind_boolean"><span class="nf">duckdb_bind_boolean</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">idx_t</span> <span class="nv">param_idx</span>, <span class="kt">bool</span> <span class="nv">val</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_bind_int8"><span class="nf">duckdb_bind_int8</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">idx_t</span> <span class="nv">param_idx</span>, <span class="kt">int8_t</span> <span class="nv">val</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_bind_int16"><span class="nf">duckdb_bind_int16</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">idx_t</span> <span class="nv">param_idx</span>, <span class="kt">int16_t</span> <span class="nv">val</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_bind_int32"><span class="nf">duckdb_bind_int32</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">idx_t</span> <span class="nv">param_idx</span>, <span class="kt">int32_t</span> <span class="nv">val</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_bind_int64"><span class="nf">duckdb_bind_int64</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">idx_t</span> <span class="nv">param_idx</span>, <span class="kt">int64_t</span> <span class="nv">val</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_bind_hugeint"><span class="nf">duckdb_bind_hugeint</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">idx_t</span> <span class="nv">param_idx</span>, <span class="kt">duckdb_hugeint</span> <span class="nv">val</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_bind_uhugeint"><span class="nf">duckdb_bind_uhugeint</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">idx_t</span> <span class="nv">param_idx</span>, <span class="nv">duckdb_uhugeint</span> <span class="nv">val</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_bind_decimal"><span class="nf">duckdb_bind_decimal</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">idx_t</span> <span class="nv">param_idx</span>, <span class="nv">duckdb_decimal</span> <span class="nv">val</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_bind_uint8"><span class="nf">duckdb_bind_uint8</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">idx_t</span> <span class="nv">param_idx</span>, <span class="kt">uint8_t</span> <span class="nv">val</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_bind_uint16"><span class="nf">duckdb_bind_uint16</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">idx_t</span> <span class="nv">param_idx</span>, <span class="kt">uint16_t</span> <span class="nv">val</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_bind_uint32"><span class="nf">duckdb_bind_uint32</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">idx_t</span> <span class="nv">param_idx</span>, <span class="kt">uint32_t</span> <span class="nv">val</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_bind_uint64"><span class="nf">duckdb_bind_uint64</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">idx_t</span> <span class="nv">param_idx</span>, <span class="kt">uint64_t</span> <span class="nv">val</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_bind_float"><span class="nf">duckdb_bind_float</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">idx_t</span> <span class="nv">param_idx</span>, <span class="kt">float</span> <span class="nv">val</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_bind_double"><span class="nf">duckdb_bind_double</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">idx_t</span> <span class="nv">param_idx</span>, <span class="kt">double</span> <span class="nv">val</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_bind_date"><span class="nf">duckdb_bind_date</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">idx_t</span> <span class="nv">param_idx</span>, <span class="kt">duckdb_date</span> <span class="nv">val</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_bind_time"><span class="nf">duckdb_bind_time</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">idx_t</span> <span class="nv">param_idx</span>, <span class="kt">duckdb_time</span> <span class="nv">val</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_bind_timestamp"><span class="nf">duckdb_bind_timestamp</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">idx_t</span> <span class="nv">param_idx</span>, <span class="kt">duckdb_timestamp</span> <span class="nv">val</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_bind_interval"><span class="nf">duckdb_bind_interval</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">idx_t</span> <span class="nv">param_idx</span>, <span class="kt">duckdb_interval</span> <span class="nv">val</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_bind_varchar"><span class="nf">duckdb_bind_varchar</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">idx_t</span> <span class="nv">param_idx</span>, <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">val</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_bind_varchar_length"><span class="nf">duckdb_bind_varchar_length</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">idx_t</span> <span class="nv">param_idx</span>, <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">val</span>, <span class="kt">idx_t</span> <span class="nv">length</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_bind_blob"><span class="nf">duckdb_bind_blob</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">idx_t</span> <span class="nv">param_idx</span>, <span class="kt">const</span> <span class="kt">void</span> *<span class="nv">data</span>, <span class="kt">idx_t</span> <span class="nv">length</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_bind_null"><span class="nf">duckdb_bind_null</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">idx_t</span> <span class="nv">param_idx</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_execute_prepared"><span class="nf">duckdb_execute_prepared</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">duckdb_result</span> *<span class="nv">out_result</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_execute_prepared_streaming"><span class="nf">duckdb_execute_prepared_streaming</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">duckdb_result</span> *<span class="nv">out_result</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_execute_prepared_arrow"><span class="nf">duckdb_execute_prepared_arrow</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="kt">duckdb_arrow</span> *<span class="nv">out_result</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_arrow_scan"><span class="nf">duckdb_arrow_scan</span></a>(<span class="kt">duckdb_connection</span> <span class="nv">connection</span>, <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">table_name</span>, <span class="nv">duckdb_arrow_stream</span> <span class="nv">arrow</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_arrow_array_scan"><span class="nf">duckdb_arrow_array_scan</span></a>(<span class="kt">duckdb_connection</span> <span class="nv">connection</span>, <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">table_name</span>, <span class="kt">duckdb_arrow_schema</span> <span class="nv">arrow_schema</span>, <span class="kt">duckdb_arrow_array</span> <span class="nv">arrow_array</span>, <span class="nv">duckdb_arrow_stream</span> *<span class="nv">out_stream</span>);
</code></pre></div></div>

### `Extract Statements`

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">idx_t</span> <a href="#duckdb_extract_statements"><span class="nf">duckdb_extract_statements</span></a>(<span class="kt">duckdb_connection</span> <span class="nv">connection</span>, <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">query</span>, <span class="nv">duckdb_extracted_statements</span> *<span class="nv">out_extracted_statements</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_prepare_extracted_statement"><span class="nf">duckdb_prepare_extracted_statement</span></a>(<span class="kt">duckdb_connection</span> <span class="nv">connection</span>, <span class="nv">duckdb_extracted_statements</span> <span class="nv">extracted_statements</span>, <span class="kt">idx_t</span> <span class="nv">index</span>, <span class="kt">duckdb_prepared_statement</span> *<span class="nv">out_prepared_statement</span>);
<span class="kt">const</span> <span class="kt">char</span> *<a href="#duckdb_extract_statements_error"><span class="nf">duckdb_extract_statements_error</span></a>(<span class="nv">duckdb_extracted_statements</span> <span class="nv">extracted_statements</span>);
<span class="kt">void</span> <a href="#duckdb_destroy_extracted"><span class="nf">duckdb_destroy_extracted</span></a>(<span class="nv">duckdb_extracted_statements</span> *<span class="nv">extracted_statements</span>);
</code></pre></div></div>

### `Pending Result Interface`

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <a href="#duckdb_pending_prepared"><span class="nf">duckdb_pending_prepared</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="nv">duckdb_pending_result</span> *<span class="nv">out_result</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_pending_prepared_streaming"><span class="nf">duckdb_pending_prepared_streaming</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>, <span class="nv">duckdb_pending_result</span> *<span class="nv">out_result</span>);
<span class="kt">void</span> <a href="#duckdb_destroy_pending"><span class="nf">duckdb_destroy_pending</span></a>(<span class="nv">duckdb_pending_result</span> *<span class="nv">pending_result</span>);
<span class="kt">const</span> <span class="kt">char</span> *<a href="#duckdb_pending_error"><span class="nf">duckdb_pending_error</span></a>(<span class="nv">duckdb_pending_result</span> <span class="nv">pending_result</span>);
<span class="nv">duckdb_pending_state</span> <a href="#duckdb_pending_execute_task"><span class="nf">duckdb_pending_execute_task</span></a>(<span class="nv">duckdb_pending_result</span> <span class="nv">pending_result</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_execute_pending"><span class="nf">duckdb_execute_pending</span></a>(<span class="nv">duckdb_pending_result</span> <span class="nv">pending_result</span>, <span class="kt">duckdb_result</span> *<span class="nv">out_result</span>);
<span class="kt">bool</span> <a href="#duckdb_pending_execution_is_finished"><span class="nf">duckdb_pending_execution_is_finished</span></a>(<span class="nv">duckdb_pending_state</span> <span class="nv">pending_state</span>);
</code></pre></div></div>

### `Value Interface`

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <a href="#duckdb_destroy_value"><span class="nf">duckdb_destroy_value</span></a>(<span class="kt">duckdb_value</span> *<span class="nv">value</span>);
<span class="kt">duckdb_value</span> <a href="#duckdb_create_varchar"><span class="nf">duckdb_create_varchar</span></a>(<span class="kt">const</span> <span class="kt">char</span> *<span class="nv">text</span>);
<span class="kt">duckdb_value</span> <a href="#duckdb_create_varchar_length"><span class="nf">duckdb_create_varchar_length</span></a>(<span class="kt">const</span> <span class="kt">char</span> *<span class="nv">text</span>, <span class="kt">idx_t</span> <span class="nv">length</span>);
<span class="kt">duckdb_value</span> <a href="#duckdb_create_int64"><span class="nf">duckdb_create_int64</span></a>(<span class="kt">int64_t</span> <span class="nv">val</span>);
<span class="kt">duckdb_value</span> <a href="#duckdb_create_struct_value"><span class="nf">duckdb_create_struct_value</span></a>(<span class="kt">duckdb_logical_type</span> <span class="nv">type</span>, <span class="kt">duckdb_value</span> *<span class="nv">values</span>);
<span class="kt">duckdb_value</span> <a href="#duckdb_create_list_value"><span class="nf">duckdb_create_list_value</span></a>(<span class="kt">duckdb_logical_type</span> <span class="nv">type</span>, <span class="kt">duckdb_value</span> *<span class="nv">values</span>, <span class="kt">idx_t</span> <span class="nv">value_count</span>);
<span class="kt">char</span> *<a href="#duckdb_get_varchar"><span class="nf">duckdb_get_varchar</span></a>(<span class="kt">duckdb_value</span> <span class="nv">value</span>);
<span class="kt">int64_t</span> <a href="#duckdb_get_int64"><span class="nf">duckdb_get_int64</span></a>(<span class="kt">duckdb_value</span> <span class="nv">value</span>);
</code></pre></div></div>

### `Logical Type Interface`

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_logical_type</span> <a href="#duckdb_create_logical_type"><span class="nf">duckdb_create_logical_type</span></a>(<span class="nv">duckdb_type</span> <span class="nv">type</span>);
<span class="kt">char</span> *<a href="#duckdb_logical_type_get_alias"><span class="nf">duckdb_logical_type_get_alias</span></a>(<span class="kt">duckdb_logical_type</span> <span class="nv">type</span>);
<span class="kt">duckdb_logical_type</span> <a href="#duckdb_create_list_type"><span class="nf">duckdb_create_list_type</span></a>(<span class="kt">duckdb_logical_type</span> <span class="nv">type</span>);
<span class="kt">duckdb_logical_type</span> <a href="#duckdb_create_map_type"><span class="nf">duckdb_create_map_type</span></a>(<span class="kt">duckdb_logical_type</span> <span class="nv">key_type</span>, <span class="kt">duckdb_logical_type</span> <span class="nv">value_type</span>);
<span class="kt">duckdb_logical_type</span> <a href="#duckdb_create_union_type"><span class="nf">duckdb_create_union_type</span></a>(<span class="kt">duckdb_logical_type</span> *<span class="nv">member_types</span>, <span class="kt">const</span> <span class="kt">char</span> **<span class="nv">member_names</span>, <span class="kt">idx_t</span> <span class="nv">member_count</span>);
<span class="kt">duckdb_logical_type</span> <a href="#duckdb_create_struct_type"><span class="nf">duckdb_create_struct_type</span></a>(<span class="kt">duckdb_logical_type</span> *<span class="nv">member_types</span>, <span class="kt">const</span> <span class="kt">char</span> **<span class="nv">member_names</span>, <span class="kt">idx_t</span> <span class="nv">member_count</span>);
<span class="kt">duckdb_logical_type</span> <a href="#duckdb_create_enum_type"><span class="nf">duckdb_create_enum_type</span></a>(<span class="kt">const</span> <span class="kt">char</span> **<span class="nv">member_names</span>, <span class="kt">idx_t</span> <span class="nv">member_count</span>);
<span class="kt">duckdb_logical_type</span> <a href="#duckdb_create_decimal_type"><span class="nf">duckdb_create_decimal_type</span></a>(<span class="kt">uint8_t</span> <span class="nv">width</span>, <span class="kt">uint8_t</span> <span class="nv">scale</span>);
<span class="nv">duckdb_type</span> <a href="#duckdb_get_type_id"><span class="nf">duckdb_get_type_id</span></a>(<span class="kt">duckdb_logical_type</span> <span class="nv">type</span>);
<span class="kt">uint8_t</span> <a href="#duckdb_decimal_width"><span class="nf">duckdb_decimal_width</span></a>(<span class="kt">duckdb_logical_type</span> <span class="nv">type</span>);
<span class="kt">uint8_t</span> <a href="#duckdb_decimal_scale"><span class="nf">duckdb_decimal_scale</span></a>(<span class="kt">duckdb_logical_type</span> <span class="nv">type</span>);
<span class="nv">duckdb_type</span> <a href="#duckdb_decimal_internal_type"><span class="nf">duckdb_decimal_internal_type</span></a>(<span class="kt">duckdb_logical_type</span> <span class="nv">type</span>);
<span class="nv">duckdb_type</span> <a href="#duckdb_enum_internal_type"><span class="nf">duckdb_enum_internal_type</span></a>(<span class="kt">duckdb_logical_type</span> <span class="nv">type</span>);
<span class="kt">uint32_t</span> <a href="#duckdb_enum_dictionary_size"><span class="nf">duckdb_enum_dictionary_size</span></a>(<span class="kt">duckdb_logical_type</span> <span class="nv">type</span>);
<span class="kt">char</span> *<a href="#duckdb_enum_dictionary_value"><span class="nf">duckdb_enum_dictionary_value</span></a>(<span class="kt">duckdb_logical_type</span> <span class="nv">type</span>, <span class="kt">idx_t</span> <span class="nv">index</span>);
<span class="kt">duckdb_logical_type</span> <a href="#duckdb_list_type_child_type"><span class="nf">duckdb_list_type_child_type</span></a>(<span class="kt">duckdb_logical_type</span> <span class="nv">type</span>);
<span class="kt">duckdb_logical_type</span> <a href="#duckdb_map_type_key_type"><span class="nf">duckdb_map_type_key_type</span></a>(<span class="kt">duckdb_logical_type</span> <span class="nv">type</span>);
<span class="kt">duckdb_logical_type</span> <a href="#duckdb_map_type_value_type"><span class="nf">duckdb_map_type_value_type</span></a>(<span class="kt">duckdb_logical_type</span> <span class="nv">type</span>);
<span class="kt">idx_t</span> <a href="#duckdb_struct_type_child_count"><span class="nf">duckdb_struct_type_child_count</span></a>(<span class="kt">duckdb_logical_type</span> <span class="nv">type</span>);
<span class="kt">char</span> *<a href="#duckdb_struct_type_child_name"><span class="nf">duckdb_struct_type_child_name</span></a>(<span class="kt">duckdb_logical_type</span> <span class="nv">type</span>, <span class="kt">idx_t</span> <span class="nv">index</span>);
<span class="kt">duckdb_logical_type</span> <a href="#duckdb_struct_type_child_type"><span class="nf">duckdb_struct_type_child_type</span></a>(<span class="kt">duckdb_logical_type</span> <span class="nv">type</span>, <span class="kt">idx_t</span> <span class="nv">index</span>);
<span class="kt">idx_t</span> <a href="#duckdb_union_type_member_count"><span class="nf">duckdb_union_type_member_count</span></a>(<span class="kt">duckdb_logical_type</span> <span class="nv">type</span>);
<span class="kt">char</span> *<a href="#duckdb_union_type_member_name"><span class="nf">duckdb_union_type_member_name</span></a>(<span class="kt">duckdb_logical_type</span> <span class="nv">type</span>, <span class="kt">idx_t</span> <span class="nv">index</span>);
<span class="kt">duckdb_logical_type</span> <a href="#duckdb_union_type_member_type"><span class="nf">duckdb_union_type_member_type</span></a>(<span class="kt">duckdb_logical_type</span> <span class="nv">type</span>, <span class="kt">idx_t</span> <span class="nv">index</span>);
<span class="kt">void</span> <a href="#duckdb_destroy_logical_type"><span class="nf">duckdb_destroy_logical_type</span></a>(<span class="kt">duckdb_logical_type</span> *<span class="nv">type</span>);
</code></pre></div></div>

### `Data Chunk Interface`

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_data_chunk</span> <a href="#duckdb_create_data_chunk"><span class="nf">duckdb_create_data_chunk</span></a>(<span class="kt">duckdb_logical_type</span> *<span class="nv">types</span>, <span class="kt">idx_t</span> <span class="nv">column_count</span>);
<span class="kt">void</span> <a href="#duckdb_destroy_data_chunk"><span class="nf">duckdb_destroy_data_chunk</span></a>(<span class="kt">duckdb_data_chunk</span> *<span class="nv">chunk</span>);
<span class="kt">void</span> <a href="#duckdb_data_chunk_reset"><span class="nf">duckdb_data_chunk_reset</span></a>(<span class="kt">duckdb_data_chunk</span> <span class="nv">chunk</span>);
<span class="kt">idx_t</span> <a href="#duckdb_data_chunk_get_column_count"><span class="nf">duckdb_data_chunk_get_column_count</span></a>(<span class="kt">duckdb_data_chunk</span> <span class="nv">chunk</span>);
<span class="kt">duckdb_vector</span> <a href="#duckdb_data_chunk_get_vector"><span class="nf">duckdb_data_chunk_get_vector</span></a>(<span class="kt">duckdb_data_chunk</span> <span class="nv">chunk</span>, <span class="kt">idx_t</span> <span class="nv">col_idx</span>);
<span class="kt">idx_t</span> <a href="#duckdb_data_chunk_get_size"><span class="nf">duckdb_data_chunk_get_size</span></a>(<span class="kt">duckdb_data_chunk</span> <span class="nv">chunk</span>);
<span class="kt">void</span> <a href="#duckdb_data_chunk_set_size"><span class="nf">duckdb_data_chunk_set_size</span></a>(<span class="kt">duckdb_data_chunk</span> <span class="nv">chunk</span>, <span class="kt">idx_t</span> <span class="nv">size</span>);
</code></pre></div></div>

### `Vector Interface`

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_logical_type</span> <a href="#duckdb_vector_get_column_type"><span class="nf">duckdb_vector_get_column_type</span></a>(<span class="kt">duckdb_vector</span> <span class="nv">vector</span>);
<span class="kt">void</span> *<a href="#duckdb_vector_get_data"><span class="nf">duckdb_vector_get_data</span></a>(<span class="kt">duckdb_vector</span> <span class="nv">vector</span>);
<span class="kt">uint64_t</span> *<a href="#duckdb_vector_get_validity"><span class="nf">duckdb_vector_get_validity</span></a>(<span class="kt">duckdb_vector</span> <span class="nv">vector</span>);
<span class="kt">void</span> <a href="#duckdb_vector_ensure_validity_writable"><span class="nf">duckdb_vector_ensure_validity_writable</span></a>(<span class="kt">duckdb_vector</span> <span class="nv">vector</span>);
<span class="kt">void</span> <a href="#duckdb_vector_assign_string_element"><span class="nf">duckdb_vector_assign_string_element</span></a>(<span class="kt">duckdb_vector</span> <span class="nv">vector</span>, <span class="kt">idx_t</span> <span class="nv">index</span>, <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">str</span>);
<span class="kt">void</span> <a href="#duckdb_vector_assign_string_element_len"><span class="nf">duckdb_vector_assign_string_element_len</span></a>(<span class="kt">duckdb_vector</span> <span class="nv">vector</span>, <span class="kt">idx_t</span> <span class="nv">index</span>, <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">str</span>, <span class="kt">idx_t</span> <span class="nv">str_len</span>);
<span class="kt">duckdb_vector</span> <a href="#duckdb_list_vector_get_child"><span class="nf">duckdb_list_vector_get_child</span></a>(<span class="kt">duckdb_vector</span> <span class="nv">vector</span>);
<span class="kt">idx_t</span> <a href="#duckdb_list_vector_get_size"><span class="nf">duckdb_list_vector_get_size</span></a>(<span class="kt">duckdb_vector</span> <span class="nv">vector</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_list_vector_set_size"><span class="nf">duckdb_list_vector_set_size</span></a>(<span class="kt">duckdb_vector</span> <span class="nv">vector</span>, <span class="kt">idx_t</span> <span class="nv">size</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_list_vector_reserve"><span class="nf">duckdb_list_vector_reserve</span></a>(<span class="kt">duckdb_vector</span> <span class="nv">vector</span>, <span class="kt">idx_t</span> <span class="nv">required_capacity</span>);
<span class="kt">duckdb_vector</span> <a href="#duckdb_struct_vector_get_child"><span class="nf">duckdb_struct_vector_get_child</span></a>(<span class="kt">duckdb_vector</span> <span class="nv">vector</span>, <span class="kt">idx_t</span> <span class="nv">index</span>);
</code></pre></div></div>

### `Validity Mask Functions`

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <a href="#duckdb_validity_row_is_valid"><span class="nf">duckdb_validity_row_is_valid</span></a>(<span class="kt">uint64_t</span> *<span class="nv">validity</span>, <span class="kt">idx_t</span> <span class="nv">row</span>);
<span class="kt">void</span> <a href="#duckdb_validity_set_row_validity"><span class="nf">duckdb_validity_set_row_validity</span></a>(<span class="kt">uint64_t</span> *<span class="nv">validity</span>, <span class="kt">idx_t</span> <span class="nv">row</span>, <span class="kt">bool</span> <span class="nv">valid</span>);
<span class="kt">void</span> <a href="#duckdb_validity_set_row_invalid"><span class="nf">duckdb_validity_set_row_invalid</span></a>(<span class="kt">uint64_t</span> *<span class="nv">validity</span>, <span class="kt">idx_t</span> <span class="nv">row</span>);
<span class="kt">void</span> <a href="#duckdb_validity_set_row_valid"><span class="nf">duckdb_validity_set_row_valid</span></a>(<span class="kt">uint64_t</span> *<span class="nv">validity</span>, <span class="kt">idx_t</span> <span class="nv">row</span>);
</code></pre></div></div>

### `Table Functions`

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_table_function</span> <a href="#duckdb_create_table_function"><span class="nf">duckdb_create_table_function</span></a>();
<span class="kt">void</span> <a href="#duckdb_destroy_table_function"><span class="nf">duckdb_destroy_table_function</span></a>(<span class="kt">duckdb_table_function</span> *<span class="nv">table_function</span>);
<span class="kt">void</span> <a href="#duckdb_table_function_set_name"><span class="nf">duckdb_table_function_set_name</span></a>(<span class="kt">duckdb_table_function</span> <span class="nv">table_function</span>, <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">name</span>);
<span class="kt">void</span> <a href="#duckdb_table_function_add_parameter"><span class="nf">duckdb_table_function_add_parameter</span></a>(<span class="kt">duckdb_table_function</span> <span class="nv">table_function</span>, <span class="kt">duckdb_logical_type</span> <span class="nv">type</span>);
<span class="kt">void</span> <a href="#duckdb_table_function_add_named_parameter"><span class="nf">duckdb_table_function_add_named_parameter</span></a>(<span class="kt">duckdb_table_function</span> <span class="nv">table_function</span>, <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">name</span>, <span class="kt">duckdb_logical_type</span> <span class="nv">type</span>);
<span class="kt">void</span> <a href="#duckdb_table_function_set_extra_info"><span class="nf">duckdb_table_function_set_extra_info</span></a>(<span class="kt">duckdb_table_function</span> <span class="nv">table_function</span>, <span class="kt">void</span> *<span class="nv">extra_info</span>, <span class="nv">duckdb_delete_callback_t</span> <span class="nv">destroy</span>);
<span class="kt">void</span> <a href="#duckdb_table_function_set_bind"><span class="nf">duckdb_table_function_set_bind</span></a>(<span class="kt">duckdb_table_function</span> <span class="nv">table_function</span>, <span class="nv">duckdb_table_function_bind_t</span> <span class="nv">bind</span>);
<span class="kt">void</span> <a href="#duckdb_table_function_set_init"><span class="nf">duckdb_table_function_set_init</span></a>(<span class="kt">duckdb_table_function</span> <span class="nv">table_function</span>, <span class="nv">duckdb_table_function_init_t</span> <span class="nv">init</span>);
<span class="kt">void</span> <a href="#duckdb_table_function_set_local_init"><span class="nf">duckdb_table_function_set_local_init</span></a>(<span class="kt">duckdb_table_function</span> <span class="nv">table_function</span>, <span class="nv">duckdb_table_function_init_t</span> <span class="nv">init</span>);
<span class="kt">void</span> <a href="#duckdb_table_function_set_function"><span class="nf">duckdb_table_function_set_function</span></a>(<span class="kt">duckdb_table_function</span> <span class="nv">table_function</span>, <span class="nv">duckdb_table_function_t</span> <span class="nv">function</span>);
<span class="kt">void</span> <a href="#duckdb_table_function_supports_projection_pushdown"><span class="nf">duckdb_table_function_supports_projection_pushdown</span></a>(<span class="kt">duckdb_table_function</span> <span class="nv">table_function</span>, <span class="kt">bool</span> <span class="nv">pushdown</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_register_table_function"><span class="nf">duckdb_register_table_function</span></a>(<span class="kt">duckdb_connection</span> <span class="nv">con</span>, <span class="kt">duckdb_table_function</span> <span class="nv">function</span>);
</code></pre></div></div>

### `Table Function Bind`

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> *<a href="#duckdb_bind_get_extra_info"><span class="nf">duckdb_bind_get_extra_info</span></a>(<span class="kt">duckdb_bind_info</span> <span class="nv">info</span>);
<span class="kt">void</span> <a href="#duckdb_bind_add_result_column"><span class="nf">duckdb_bind_add_result_column</span></a>(<span class="kt">duckdb_bind_info</span> <span class="nv">info</span>, <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">name</span>, <span class="kt">duckdb_logical_type</span> <span class="nv">type</span>);
<span class="kt">idx_t</span> <a href="#duckdb_bind_get_parameter_count"><span class="nf">duckdb_bind_get_parameter_count</span></a>(<span class="kt">duckdb_bind_info</span> <span class="nv">info</span>);
<span class="kt">duckdb_value</span> <a href="#duckdb_bind_get_parameter"><span class="nf">duckdb_bind_get_parameter</span></a>(<span class="kt">duckdb_bind_info</span> <span class="nv">info</span>, <span class="kt">idx_t</span> <span class="nv">index</span>);
<span class="kt">duckdb_value</span> <a href="#duckdb_bind_get_named_parameter"><span class="nf">duckdb_bind_get_named_parameter</span></a>(<span class="kt">duckdb_bind_info</span> <span class="nv">info</span>, <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">name</span>);
<span class="kt">void</span> <a href="#duckdb_bind_set_bind_data"><span class="nf">duckdb_bind_set_bind_data</span></a>(<span class="kt">duckdb_bind_info</span> <span class="nv">info</span>, <span class="kt">void</span> *<span class="nv">bind_data</span>, <span class="nv">duckdb_delete_callback_t</span> <span class="nv">destroy</span>);
<span class="kt">void</span> <a href="#duckdb_bind_set_cardinality"><span class="nf">duckdb_bind_set_cardinality</span></a>(<span class="kt">duckdb_bind_info</span> <span class="nv">info</span>, <span class="kt">idx_t</span> <span class="nv">cardinality</span>, <span class="kt">bool</span> <span class="nv">is_exact</span>);
<span class="kt">void</span> <a href="#duckdb_bind_set_error"><span class="nf">duckdb_bind_set_error</span></a>(<span class="kt">duckdb_bind_info</span> <span class="nv">info</span>, <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">error</span>);
</code></pre></div></div>

### `Table Function Init`

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> *<a href="#duckdb_init_get_extra_info"><span class="nf">duckdb_init_get_extra_info</span></a>(<span class="kt">duckdb_init_info</span> <span class="nv">info</span>);
<span class="kt">void</span> *<a href="#duckdb_init_get_bind_data"><span class="nf">duckdb_init_get_bind_data</span></a>(<span class="kt">duckdb_init_info</span> <span class="nv">info</span>);
<span class="kt">void</span> <a href="#duckdb_init_set_init_data"><span class="nf">duckdb_init_set_init_data</span></a>(<span class="kt">duckdb_init_info</span> <span class="nv">info</span>, <span class="kt">void</span> *<span class="nv">init_data</span>, <span class="nv">duckdb_delete_callback_t</span> <span class="nv">destroy</span>);
<span class="kt">idx_t</span> <a href="#duckdb_init_get_column_count"><span class="nf">duckdb_init_get_column_count</span></a>(<span class="kt">duckdb_init_info</span> <span class="nv">info</span>);
<span class="kt">idx_t</span> <a href="#duckdb_init_get_column_index"><span class="nf">duckdb_init_get_column_index</span></a>(<span class="kt">duckdb_init_info</span> <span class="nv">info</span>, <span class="kt">idx_t</span> <span class="nv">column_index</span>);
<span class="kt">void</span> <a href="#duckdb_init_set_max_threads"><span class="nf">duckdb_init_set_max_threads</span></a>(<span class="kt">duckdb_init_info</span> <span class="nv">info</span>, <span class="kt">idx_t</span> <span class="nv">max_threads</span>);
<span class="kt">void</span> <a href="#duckdb_init_set_error"><span class="nf">duckdb_init_set_error</span></a>(<span class="kt">duckdb_init_info</span> <span class="nv">info</span>, <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">error</span>);
</code></pre></div></div>

### `Table Function`

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> *<a href="#duckdb_function_get_extra_info"><span class="nf">duckdb_function_get_extra_info</span></a>(<span class="kt">duckdb_function_info</span> <span class="nv">info</span>);
<span class="kt">void</span> *<a href="#duckdb_function_get_bind_data"><span class="nf">duckdb_function_get_bind_data</span></a>(<span class="kt">duckdb_function_info</span> <span class="nv">info</span>);
<span class="kt">void</span> *<a href="#duckdb_function_get_init_data"><span class="nf">duckdb_function_get_init_data</span></a>(<span class="kt">duckdb_function_info</span> <span class="nv">info</span>);
<span class="kt">void</span> *<a href="#duckdb_function_get_local_init_data"><span class="nf">duckdb_function_get_local_init_data</span></a>(<span class="kt">duckdb_function_info</span> <span class="nv">info</span>);
<span class="kt">void</span> <a href="#duckdb_function_set_error"><span class="nf">duckdb_function_set_error</span></a>(<span class="kt">duckdb_function_info</span> <span class="nv">info</span>, <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">error</span>);
</code></pre></div></div>

### `Replacement Scans`

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <a href="#duckdb_add_replacement_scan"><span class="nf">duckdb_add_replacement_scan</span></a>(<span class="kt">duckdb_database</span> <span class="nv">db</span>, <span class="nv">duckdb_replacement_callback_t</span> <span class="nv">replacement</span>, <span class="kt">void</span> *<span class="nv">extra_data</span>, <span class="nv">duckdb_delete_callback_t</span> <span class="nv">delete_callback</span>);
<span class="kt">void</span> <a href="#duckdb_replacement_scan_set_function_name"><span class="nf">duckdb_replacement_scan_set_function_name</span></a>(<span class="kt">duckdb_replacement_scan_info</span> <span class="nv">info</span>, <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">function_name</span>);
<span class="kt">void</span> <a href="#duckdb_replacement_scan_add_parameter"><span class="nf">duckdb_replacement_scan_add_parameter</span></a>(<span class="kt">duckdb_replacement_scan_info</span> <span class="nv">info</span>, <span class="kt">duckdb_value</span> <span class="nv">parameter</span>);
<span class="kt">void</span> <a href="#duckdb_replacement_scan_set_error"><span class="nf">duckdb_replacement_scan_set_error</span></a>(<span class="kt">duckdb_replacement_scan_info</span> <span class="nv">info</span>, <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">error</span>);
</code></pre></div></div>

### `Appender`

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <a href="#duckdb_appender_create"><span class="nf">duckdb_appender_create</span></a>(<span class="kt">duckdb_connection</span> <span class="nv">connection</span>, <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">schema</span>, <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">table</span>, <span class="kt">duckdb_appender</span> *<span class="nv">out_appender</span>);
<span class="kt">const</span> <span class="kt">char</span> *<a href="#duckdb_appender_error"><span class="nf">duckdb_appender_error</span></a>(<span class="kt">duckdb_appender</span> <span class="nv">appender</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_appender_flush"><span class="nf">duckdb_appender_flush</span></a>(<span class="kt">duckdb_appender</span> <span class="nv">appender</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_appender_close"><span class="nf">duckdb_appender_close</span></a>(<span class="kt">duckdb_appender</span> <span class="nv">appender</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_appender_destroy"><span class="nf">duckdb_appender_destroy</span></a>(<span class="kt">duckdb_appender</span> *<span class="nv">appender</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_appender_begin_row"><span class="nf">duckdb_appender_begin_row</span></a>(<span class="kt">duckdb_appender</span> <span class="nv">appender</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_appender_end_row"><span class="nf">duckdb_appender_end_row</span></a>(<span class="kt">duckdb_appender</span> <span class="nv">appender</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_append_bool"><span class="nf">duckdb_append_bool</span></a>(<span class="kt">duckdb_appender</span> <span class="nv">appender</span>, <span class="kt">bool</span> <span class="nv">value</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_append_int8"><span class="nf">duckdb_append_int8</span></a>(<span class="kt">duckdb_appender</span> <span class="nv">appender</span>, <span class="kt">int8_t</span> <span class="nv">value</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_append_int16"><span class="nf">duckdb_append_int16</span></a>(<span class="kt">duckdb_appender</span> <span class="nv">appender</span>, <span class="kt">int16_t</span> <span class="nv">value</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_append_int32"><span class="nf">duckdb_append_int32</span></a>(<span class="kt">duckdb_appender</span> <span class="nv">appender</span>, <span class="kt">int32_t</span> <span class="nv">value</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_append_int64"><span class="nf">duckdb_append_int64</span></a>(<span class="kt">duckdb_appender</span> <span class="nv">appender</span>, <span class="kt">int64_t</span> <span class="nv">value</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_append_hugeint"><span class="nf">duckdb_append_hugeint</span></a>(<span class="kt">duckdb_appender</span> <span class="nv">appender</span>, <span class="kt">duckdb_hugeint</span> <span class="nv">value</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_append_uint8"><span class="nf">duckdb_append_uint8</span></a>(<span class="kt">duckdb_appender</span> <span class="nv">appender</span>, <span class="kt">uint8_t</span> <span class="nv">value</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_append_uint16"><span class="nf">duckdb_append_uint16</span></a>(<span class="kt">duckdb_appender</span> <span class="nv">appender</span>, <span class="kt">uint16_t</span> <span class="nv">value</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_append_uint32"><span class="nf">duckdb_append_uint32</span></a>(<span class="kt">duckdb_appender</span> <span class="nv">appender</span>, <span class="kt">uint32_t</span> <span class="nv">value</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_append_uint64"><span class="nf">duckdb_append_uint64</span></a>(<span class="kt">duckdb_appender</span> <span class="nv">appender</span>, <span class="kt">uint64_t</span> <span class="nv">value</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_append_uhugeint"><span class="nf">duckdb_append_uhugeint</span></a>(<span class="kt">duckdb_appender</span> <span class="nv">appender</span>, <span class="nv">duckdb_uhugeint</span> <span class="nv">value</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_append_float"><span class="nf">duckdb_append_float</span></a>(<span class="kt">duckdb_appender</span> <span class="nv">appender</span>, <span class="kt">float</span> <span class="nv">value</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_append_double"><span class="nf">duckdb_append_double</span></a>(<span class="kt">duckdb_appender</span> <span class="nv">appender</span>, <span class="kt">double</span> <span class="nv">value</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_append_date"><span class="nf">duckdb_append_date</span></a>(<span class="kt">duckdb_appender</span> <span class="nv">appender</span>, <span class="kt">duckdb_date</span> <span class="nv">value</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_append_time"><span class="nf">duckdb_append_time</span></a>(<span class="kt">duckdb_appender</span> <span class="nv">appender</span>, <span class="kt">duckdb_time</span> <span class="nv">value</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_append_timestamp"><span class="nf">duckdb_append_timestamp</span></a>(<span class="kt">duckdb_appender</span> <span class="nv">appender</span>, <span class="kt">duckdb_timestamp</span> <span class="nv">value</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_append_interval"><span class="nf">duckdb_append_interval</span></a>(<span class="kt">duckdb_appender</span> <span class="nv">appender</span>, <span class="kt">duckdb_interval</span> <span class="nv">value</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_append_varchar"><span class="nf">duckdb_append_varchar</span></a>(<span class="kt">duckdb_appender</span> <span class="nv">appender</span>, <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">val</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_append_varchar_length"><span class="nf">duckdb_append_varchar_length</span></a>(<span class="kt">duckdb_appender</span> <span class="nv">appender</span>, <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">val</span>, <span class="kt">idx_t</span> <span class="nv">length</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_append_blob"><span class="nf">duckdb_append_blob</span></a>(<span class="kt">duckdb_appender</span> <span class="nv">appender</span>, <span class="kt">const</span> <span class="kt">void</span> *<span class="nv">data</span>, <span class="kt">idx_t</span> <span class="nv">length</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_append_null"><span class="nf">duckdb_append_null</span></a>(<span class="kt">duckdb_appender</span> <span class="nv">appender</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_append_data_chunk"><span class="nf">duckdb_append_data_chunk</span></a>(<span class="kt">duckdb_appender</span> <span class="nv">appender</span>, <span class="kt">duckdb_data_chunk</span> <span class="nv">chunk</span>);
</code></pre></div></div>

### `Arrow Interface`

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <a href="#duckdb_query_arrow"><span class="nf">duckdb_query_arrow</span></a>(<span class="kt">duckdb_connection</span> <span class="nv">connection</span>, <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">query</span>, <span class="kt">duckdb_arrow</span> *<span class="nv">out_result</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_query_arrow_schema"><span class="nf">duckdb_query_arrow_schema</span></a>(<span class="kt">duckdb_arrow</span> <span class="nv">result</span>, <span class="kt">duckdb_arrow_schema</span> *<span class="nv">out_schema</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_prepared_arrow_schema"><span class="nf">duckdb_prepared_arrow_schema</span></a>(<span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared</span>, <span class="kt">duckdb_arrow_schema</span> *<span class="nv">out_schema</span>);
<span class="kt">void</span> <a href="#duckdb_result_arrow_array"><span class="nf">duckdb_result_arrow_array</span></a>(<span class="kt">duckdb_result</span> <span class="nv">result</span>, <span class="kt">duckdb_data_chunk</span> <span class="nv">chunk</span>, <span class="kt">duckdb_arrow_array</span> *<span class="nv">out_array</span>);
<span class="kt">duckdb_state</span> <a href="#duckdb_query_arrow_array"><span class="nf">duckdb_query_arrow_array</span></a>(<span class="kt">duckdb_arrow</span> <span class="nv">result</span>, <span class="kt">duckdb_arrow_array</span> *<span class="nv">out_array</span>);
<span class="kt">idx_t</span> <a href="#duckdb_arrow_column_count"><span class="nf">duckdb_arrow_column_count</span></a>(<span class="kt">duckdb_arrow</span> <span class="nv">result</span>);
<span class="kt">idx_t</span> <a href="#duckdb_arrow_row_count"><span class="nf">duckdb_arrow_row_count</span></a>(<span class="kt">duckdb_arrow</span> <span class="nv">result</span>);
<span class="kt">idx_t</span> <a href="#duckdb_arrow_rows_changed"><span class="nf">duckdb_arrow_rows_changed</span></a>(<span class="kt">duckdb_arrow</span> <span class="nv">result</span>);
<span class="kt">const</span> <span class="kt">char</span> *<a href="#duckdb_query_arrow_error"><span class="nf">duckdb_query_arrow_error</span></a>(<span class="kt">duckdb_arrow</span> <span class="nv">result</span>);
<span class="kt">void</span> <a href="#duckdb_destroy_arrow"><span class="nf">duckdb_destroy_arrow</span></a>(<span class="kt">duckdb_arrow</span> *<span class="nv">result</span>);
</code></pre></div></div>

### `Threading Information`

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <a href="#duckdb_execute_tasks"><span class="nf">duckdb_execute_tasks</span></a>(<span class="kt">duckdb_database</span> <span class="nv">database</span>, <span class="kt">idx_t</span> <span class="nv">max_tasks</span>);
<span class="nv">duckdb_task_state</span> <a href="#duckdb_create_task_state"><span class="nf">duckdb_create_task_state</span></a>(<span class="kt">duckdb_database</span> <span class="nv">database</span>);
<span class="kt">void</span> <a href="#duckdb_execute_tasks_state"><span class="nf">duckdb_execute_tasks_state</span></a>(<span class="nv">duckdb_task_state</span> <span class="nv">state</span>);
<span class="kt">idx_t</span> <a href="#duckdb_execute_n_tasks_state"><span class="nf">duckdb_execute_n_tasks_state</span></a>(<span class="nv">duckdb_task_state</span> <span class="nv">state</span>, <span class="kt">idx_t</span> <span class="nv">max_tasks</span>);
<span class="kt">void</span> <a href="#duckdb_finish_execution"><span class="nf">duckdb_finish_execution</span></a>(<span class="nv">duckdb_task_state</span> <span class="nv">state</span>);
<span class="kt">bool</span> <a href="#duckdb_task_state_is_finished"><span class="nf">duckdb_task_state_is_finished</span></a>(<span class="nv">duckdb_task_state</span> <span class="nv">state</span>);
<span class="kt">void</span> <a href="#duckdb_destroy_task_state"><span class="nf">duckdb_destroy_task_state</span></a>(<span class="nv">duckdb_task_state</span> <span class="nv">state</span>);
<span class="kt">bool</span> <a href="#duckdb_execution_is_finished"><span class="nf">duckdb_execution_is_finished</span></a>(<span class="kt">duckdb_connection</span> <span class="nv">con</span>);
</code></pre></div></div>

### `Streaming Result Interface`

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_data_chunk</span> <a href="#duckdb_stream_fetch_chunk"><span class="nf">duckdb_stream_fetch_chunk</span></a>(<span class="kt">duckdb_result</span> <span class="nv">result</span>);
</code></pre></div></div>

### `duckdb_open`

---
Creates a new database or opens an existing database file stored at the given path.
If no path is given a new in-memory database is created instead.
The instantiated database should be closed with 'duckdb_close'

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_open</span>(<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">path</span>,<span class="nv">
</span>  <span class="kt">duckdb_database</span> *<span class="nv">out_database
</span>);
</code></pre></div></div>

#### Parameters

---
* `path`

Path to the database file on disk, or `nullptr` or `:memory:` to open an in-memory database.
* `out_database`

The result database object.
* `returns`

`DuckDBSuccess` on success or `DuckDBError` on failure.

<br>


### `duckdb_open_ext`

---
Extended version of duckdb_open. Creates a new database or opens an existing database file stored at the given path.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_open_ext</span>(<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">path</span>,<span class="nv">
</span>  <span class="kt">duckdb_database</span> *<span class="nv">out_database</span>,<span class="nv">
</span>  <span class="kt">duckdb_config</span> <span class="nv">config</span>,<span class="nv">
</span>  <span class="kt">char</span> **<span class="nv">out_error
</span>);
</code></pre></div></div>

#### Parameters

---
* `path`

Path to the database file on disk, or `nullptr` or `:memory:` to open an in-memory database.
* `out_database`

The result database object.
* `config`

(Optional) configuration used to start up the database system.
* `out_error`

If set and the function returns DuckDBError, this will contain the reason why the start-up failed.
Note that the error must be freed using `duckdb_free`.
* `returns`

`DuckDBSuccess` on success or `DuckDBError` on failure.

<br>


### `duckdb_close`

---
Closes the specified database and de-allocates all memory allocated for that database.
This should be called after you are done with any database allocated through `duckdb_open`.
Note that failing to call `duckdb_close` (in case of e.g., a program crash) will not cause data corruption.
Still it is recommended to always correctly close a database object after you are done with it.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_close</span>(<span class="nv">
</span>  <span class="kt">duckdb_database</span> *<span class="nv">database
</span>);
</code></pre></div></div>

#### Parameters

---
* `database`

The database object to shut down.

<br>


### `duckdb_connect`

---
Opens a connection to a database. Connections are required to query the database, and store transactional state
associated with the connection.
The instantiated connection should be closed using 'duckdb_disconnect'

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_connect</span>(<span class="nv">
</span>  <span class="kt">duckdb_database</span> <span class="nv">database</span>,<span class="nv">
</span>  <span class="kt">duckdb_connection</span> *<span class="nv">out_connection
</span>);
</code></pre></div></div>

#### Parameters

---
* `database`

The database file to connect to.
* `out_connection`

The result connection object.
* `returns`

`DuckDBSuccess` on success or `DuckDBError` on failure.

<br>


### `duckdb_interrupt`

---
Interrupt running query

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_interrupt</span>(<span class="nv">
</span>  <span class="kt">duckdb_connection</span> <span class="nv">connection
</span>);
</code></pre></div></div>

#### Parameters

---
* `connection`

The connection to interruot

<br>


### `duckdb_query_progress`

---
Get progress of the running query

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">duckdb_query_progress_type</span> <span class="nv">duckdb_query_progress</span>(<span class="nv">
</span>  <span class="kt">duckdb_connection</span> <span class="nv">connection
</span>);
</code></pre></div></div>

#### Parameters

---
* `connection`

The working connection
* `returns`

-1 if no progress or a percentage of the progress

<br>


### `duckdb_disconnect`

---
Closes the specified connection and de-allocates all memory allocated for that connection.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_disconnect</span>(<span class="nv">
</span>  <span class="kt">duckdb_connection</span> *<span class="nv">connection
</span>);
</code></pre></div></div>

#### Parameters

---
* `connection`

The connection to close.

<br>


### `duckdb_library_version`

---
Returns the version of the linked DuckDB, with a version postfix for dev versions

Usually used for developing C extensions that must return this for a compatibility check.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">const</span> <span class="kt">char</span> *<span class="nv">duckdb_library_version</span>(<span class="nv">
</span>  <span class="nv">
</span>);
</code></pre></div></div>
<br>


### `duckdb_create_config`

---
Initializes an empty configuration object that can be used to provide start-up options for the DuckDB instance
through `duckdb_open_ext`.

This will always succeed unless there is a malloc failure.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_create_config</span>(<span class="nv">
</span>  <span class="kt">duckdb_config</span> *<span class="nv">out_config
</span>);
</code></pre></div></div>

#### Parameters

---
* `out_config`

The result configuration object.
* `returns`

`DuckDBSuccess` on success or `DuckDBError` on failure.

<br>


### `duckdb_config_count`

---
This returns the total amount of configuration options available for usage with `duckdb_get_config_flag`.

This should not be called in a loop as it internally loops over all the options.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span> <span class="nv">duckdb_config_count</span>(<span class="nv">
</span>  <span class="nv">
</span>);
</code></pre></div></div>

#### Parameters

---
* `returns`

The amount of config options available.

<br>


### `duckdb_get_config_flag`

---
Obtains a human-readable name and description of a specific configuration option. This can be used to e.g.
display configuration options. This will succeed unless `index` is out of range (i.e., `>= duckdb_config_count`).

The result name or description MUST NOT be freed.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_get_config_flag</span>(<span class="nv">
</span>  <span class="kt">size_t</span> <span class="nv">index</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> **<span class="nv">out_name</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> **<span class="nv">out_description
</span>);
</code></pre></div></div>

#### Parameters

---
* `index`

The index of the configuration option (between 0 and `duckdb_config_count`)
* `out_name`

A name of the configuration flag.
* `out_description`

A description of the configuration flag.
* `returns`

`DuckDBSuccess` on success or `DuckDBError` on failure.

<br>


### `duckdb_set_config`

---
Sets the specified option for the specified configuration. The configuration option is indicated by name.
To obtain a list of config options, see `duckdb_get_config_flag`.

In the source code, configuration options are defined in `config.cpp`.

This can fail if either the name is invalid, or if the value provided for the option is invalid.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_set_config</span>(<span class="nv">
</span>  <span class="kt">duckdb_config</span> <span class="nv">config</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">name</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">option
</span>);
</code></pre></div></div>

#### Parameters

---
* `duckdb_config`

The configuration object to set the option on.
* `name`

The name of the configuration flag to set.
* `option`

The value to set the configuration flag to.
* `returns`

`DuckDBSuccess` on success or `DuckDBError` on failure.

<br>


### `duckdb_destroy_config`

---
Destroys the specified configuration option and de-allocates all memory allocated for the object.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_destroy_config</span>(<span class="nv">
</span>  <span class="kt">duckdb_config</span> *<span class="nv">config
</span>);
</code></pre></div></div>

#### Parameters

---
* `config`

The configuration object to destroy.

<br>


### `duckdb_query`

---
Executes a SQL query within a connection and stores the full (materialized) result in the out_result pointer.
If the query fails to execute, DuckDBError is returned and the error message can be retrieved by calling
`duckdb_result_error`.

Note that after running `duckdb_query`, `duckdb_destroy_result` must be called on the result object even if the
query fails, otherwise the error stored within the result will not be freed correctly.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_query</span>(<span class="nv">
</span>  <span class="kt">duckdb_connection</span> <span class="nv">connection</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">query</span>,<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">out_result
</span>);
</code></pre></div></div>

#### Parameters

---
* `connection`

The connection to perform the query in.
* `query`

The SQL query to run.
* `out_result`

The query result.
* `returns`

`DuckDBSuccess` on success or `DuckDBError` on failure.

<br>


### `duckdb_destroy_result`

---
Closes the result and de-allocates all memory allocated for that connection.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_destroy_result</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result
</span>);
</code></pre></div></div>

#### Parameters

---
* `result`

The result to destroy.

<br>


### `duckdb_column_name`

---
Returns the column name of the specified column. The result should not need be freed; the column names will
automatically be destroyed when the result is destroyed.

Returns `NULL` if the column is out of range.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">const</span> <span class="kt">char</span> *<span class="nv">duckdb_column_name</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col
</span>);
</code></pre></div></div>

#### Parameters

---
* `result`

The result object to fetch the column name from.
* `col`

The column index.
* `returns`

The column name of the specified column.

<br>


### `duckdb_column_type`

---
Returns the column type of the specified column.

Returns `DUCKDB_TYPE_INVALID` if the column is out of range.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">duckdb_type</span> <span class="nv">duckdb_column_type</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col
</span>);
</code></pre></div></div>

#### Parameters

---
* `result`

The result object to fetch the column type from.
* `col`

The column index.
* `returns`

The column type of the specified column.

<br>


### `duckdb_result_statement_type`

---
Returns the statement type of the statement that was executed

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">duckdb_statement_type</span> <span class="nv">duckdb_result_statement_type</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> <span class="nv">result
</span>);
</code></pre></div></div>

#### Parameters

---
* `result`

The result object to fetch the statement type from.
* `returns`

duckdb_statement_type value or DUCKDB_STATEMENT_TYPE_INVALID

<br>


### `duckdb_column_logical_type`

---
Returns the logical column type of the specified column.

The return type of this call should be destroyed with `duckdb_destroy_logical_type`.

Returns `NULL` if the column is out of range.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_logical_type</span> <span class="nv">duckdb_column_logical_type</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col
</span>);
</code></pre></div></div>

#### Parameters

---
* `result`

The result object to fetch the column type from.
* `col`

The column index.
* `returns`

The logical column type of the specified column.

<br>


### `duckdb_column_count`

---
Returns the number of columns present in a the result object.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">idx_t</span> <span class="nv">duckdb_column_count</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result
</span>);
</code></pre></div></div>

#### Parameters

---
* `result`

The result object.
* `returns`

The number of columns present in the result object.

<br>


### `duckdb_row_count`

---
Returns the number of rows present in a the result object.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">idx_t</span> <span class="nv">duckdb_row_count</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result
</span>);
</code></pre></div></div>

#### Parameters

---
* `result`

The result object.
* `returns`

The number of rows present in the result object.

<br>


### `duckdb_rows_changed`

---
Returns the number of rows changed by the query stored in the result. This is relevant only for INSERT/UPDATE/DELETE
queries. For other queries the rows_changed will be 0.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">idx_t</span> <span class="nv">duckdb_rows_changed</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result
</span>);
</code></pre></div></div>

#### Parameters

---
* `result`

The result object.
* `returns`

The number of rows changed.

<br>


### `duckdb_column_data`

---
**DEPRECATED**: Prefer using `duckdb_result_get_chunk` instead.

Returns the data of a specific column of a result in columnar format.

The function returns a dense array which contains the result data. The exact type stored in the array depends on the
corresponding duckdb_type (as provided by `duckdb_column_type`). For the exact type by which the data should be
accessed, see the comments in [the types section](types) or the `DUCKDB_TYPE` enum.

For example, for a column of type `DUCKDB_TYPE_INTEGER`, rows can be accessed in the following manner:
```c
int32_t *data = (int32_t *) duckdb_column_data(&result, 0);
printf("Data for row %d: %d\n", row, data[row]);
```

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> *<span class="nv">duckdb_column_data</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col
</span>);
</code></pre></div></div>

#### Parameters

---
* `result`

The result object to fetch the column data from.
* `col`

The column index.
* `returns`

The column data of the specified column.

<br>


### `duckdb_nullmask_data`

---
**DEPRECATED**: Prefer using `duckdb_result_get_chunk` instead.

Returns the nullmask of a specific column of a result in columnar format. The nullmask indicates for every row
whether or not the corresponding row is `NULL`. If a row is `NULL`, the values present in the array provided
by `duckdb_column_data` are undefined.

```c
int32_t *data = (int32_t *) duckdb_column_data(&result, 0);
bool *nullmask = duckdb_nullmask_data(&result, 0);
if (nullmask[row]) {
printf("Data for row %d: NULL\n", row);
} else {
printf("Data for row %d: %d\n", row, data[row]);
}
```

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> *<span class="nv">duckdb_nullmask_data</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col
</span>);
</code></pre></div></div>

#### Parameters

---
* `result`

The result object to fetch the nullmask from.
* `col`

The column index.
* `returns`

The nullmask of the specified column.

<br>


### `duckdb_result_error`

---
Returns the error message contained within the result. The error is only set if `duckdb_query` returns `DuckDBError`.

The result of this function must not be freed. It will be cleaned up when `duckdb_destroy_result` is called.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">const</span> <span class="kt">char</span> *<span class="nv">duckdb_result_error</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result
</span>);
</code></pre></div></div>

#### Parameters

---
* `result`

The result object to fetch the error from.
* `returns`

The error of the result.

<br>


### `duckdb_result_get_chunk`

---
Fetches a data chunk from the duckdb_result. This function should be called repeatedly until the result is exhausted.

The result must be destroyed with `duckdb_destroy_data_chunk`.

This function supersedes all `duckdb_value` functions, as well as the `duckdb_column_data` and `duckdb_nullmask_data`
functions. It results in significantly better performance, and should be preferred in newer code-bases.

If this function is used, none of the other result functions can be used and vice versa (i.e., this function cannot be
mixed with the legacy result functions).

Use `duckdb_result_chunk_count` to figure out how many chunks there are in the result.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_data_chunk</span> <span class="nv">duckdb_result_get_chunk</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> <span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">chunk_index
</span>);
</code></pre></div></div>

#### Parameters

---
* `result`

The result object to fetch the data chunk from.
* `chunk_index`

The chunk index to fetch from.
* `returns`

The resulting data chunk. Returns `NULL` if the chunk index is out of bounds.

<br>


### `duckdb_result_is_streaming`

---
Checks if the type of the internal result is StreamQueryResult.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nv">duckdb_result_is_streaming</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> <span class="nv">result
</span>);
</code></pre></div></div>

#### Parameters

---
* `result`

The result object to check.
* `returns`

Whether or not the result object is of the type StreamQueryResult

<br>


### `duckdb_result_chunk_count`

---
Returns the number of data chunks present in the result.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">idx_t</span> <span class="nv">duckdb_result_chunk_count</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> <span class="nv">result
</span>);
</code></pre></div></div>

#### Parameters

---
* `result`

The result object
* `returns`

Number of data chunks present in the result.

<br>


### `duckdb_result_return_type`

---
Returns the return_type of the given result, or DUCKDB_RETURN_TYPE_INVALID on error

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">duckdb_result_type</span> <span class="nv">duckdb_result_return_type</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> <span class="nv">result
</span>);
</code></pre></div></div>

#### Parameters

---
* `result`

The result object
* `returns`

The return_type

<br>


### `duckdb_value_boolean`

---

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nv">duckdb_value_boolean</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">row
</span>);
</code></pre></div></div>

#### Parameters

---
* `returns`

The boolean value at the specified location, or false if the value cannot be converted.

<br>


### `duckdb_value_int8`

---

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int8_t</span> <span class="nv">duckdb_value_int8</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">row
</span>);
</code></pre></div></div>

#### Parameters

---
* `returns`

The int8_t value at the specified location, or 0 if the value cannot be converted.

<br>


### `duckdb_value_int16`

---

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int16_t</span> <span class="nv">duckdb_value_int16</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">row
</span>);
</code></pre></div></div>

#### Parameters

---
* `returns`

The int16_t value at the specified location, or 0 if the value cannot be converted.

<br>


### `duckdb_value_int32`

---

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int32_t</span> <span class="nv">duckdb_value_int32</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">row
</span>);
</code></pre></div></div>

#### Parameters

---
* `returns`

The int32_t value at the specified location, or 0 if the value cannot be converted.

<br>


### `duckdb_value_int64`

---

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int64_t</span> <span class="nv">duckdb_value_int64</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">row
</span>);
</code></pre></div></div>

#### Parameters

---
* `returns`

The int64_t value at the specified location, or 0 if the value cannot be converted.

<br>


### `duckdb_value_hugeint`

---

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_hugeint</span> <span class="nv">duckdb_value_hugeint</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">row
</span>);
</code></pre></div></div>

#### Parameters

---
* `returns`

The duckdb_hugeint value at the specified location, or 0 if the value cannot be converted.

<br>


### `duckdb_value_uhugeint`

---

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">duckdb_uhugeint</span> <span class="nv">duckdb_value_uhugeint</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">row
</span>);
</code></pre></div></div>

#### Parameters

---
* `returns`

The duckdb_uhugeint value at the specified location, or 0 if the value cannot be converted.

<br>


### `duckdb_value_decimal`

---

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">duckdb_decimal</span> <span class="nv">duckdb_value_decimal</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">row
</span>);
</code></pre></div></div>

#### Parameters

---
* `returns`

The duckdb_decimal value at the specified location, or 0 if the value cannot be converted.

<br>


### `duckdb_value_uint8`

---

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint8_t</span> <span class="nv">duckdb_value_uint8</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">row
</span>);
</code></pre></div></div>

#### Parameters

---
* `returns`

The uint8_t value at the specified location, or 0 if the value cannot be converted.

<br>


### `duckdb_value_uint16`

---

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint16_t</span> <span class="nv">duckdb_value_uint16</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">row
</span>);
</code></pre></div></div>

#### Parameters

---
* `returns`

The uint16_t value at the specified location, or 0 if the value cannot be converted.

<br>


### `duckdb_value_uint32`

---

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint32_t</span> <span class="nv">duckdb_value_uint32</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">row
</span>);
</code></pre></div></div>

#### Parameters

---
* `returns`

The uint32_t value at the specified location, or 0 if the value cannot be converted.

<br>


### `duckdb_value_uint64`

---

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="nv">duckdb_value_uint64</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">row
</span>);
</code></pre></div></div>

#### Parameters

---
* `returns`

The uint64_t value at the specified location, or 0 if the value cannot be converted.

<br>


### `duckdb_value_float`

---

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nv">duckdb_value_float</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">row
</span>);
</code></pre></div></div>

#### Parameters

---
* `returns`

The float value at the specified location, or 0 if the value cannot be converted.

<br>


### `duckdb_value_double`

---

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="nv">duckdb_value_double</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">row
</span>);
</code></pre></div></div>

#### Parameters

---
* `returns`

The double value at the specified location, or 0 if the value cannot be converted.

<br>


### `duckdb_value_date`

---

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_date</span> <span class="nv">duckdb_value_date</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">row
</span>);
</code></pre></div></div>

#### Parameters

---
* `returns`

The duckdb_date value at the specified location, or 0 if the value cannot be converted.

<br>


### `duckdb_value_time`

---

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_time</span> <span class="nv">duckdb_value_time</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">row
</span>);
</code></pre></div></div>

#### Parameters

---
* `returns`

The duckdb_time value at the specified location, or 0 if the value cannot be converted.

<br>


### `duckdb_value_timestamp`

---

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_timestamp</span> <span class="nv">duckdb_value_timestamp</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">row
</span>);
</code></pre></div></div>

#### Parameters

---
* `returns`

The duckdb_timestamp value at the specified location, or 0 if the value cannot be converted.

<br>


### `duckdb_value_interval`

---

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_interval</span> <span class="nv">duckdb_value_interval</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">row
</span>);
</code></pre></div></div>

#### Parameters

---
* `returns`

The duckdb_interval value at the specified location, or 0 if the value cannot be converted.

<br>


### `duckdb_value_varchar`

---

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> *<span class="nv">duckdb_value_varchar</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">row
</span>);
</code></pre></div></div>

#### Parameters

---
* `DEPRECATED`

use duckdb_value_string instead. This function does not work correctly if the string contains null bytes.
* `returns`

The text value at the specified location as a null-terminated string, or nullptr if the value cannot be
converted. The result must be freed with `duckdb_free`.

<br>


### `duckdb_value_varchar_internal`

---

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> *<span class="nv">duckdb_value_varchar_internal</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">row
</span>);
</code></pre></div></div>

#### Parameters

---
* `DEPRECATED`

use duckdb_value_string_internal instead. This function does not work correctly if the string contains
null bytes.
* `returns`

The char* value at the specified location. ONLY works on VARCHAR columns and does not auto-cast.
If the column is NOT a VARCHAR column this function will return NULL.

The result must NOT be freed.

<br>


### `duckdb_value_string_internal`

---

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">duckdb_string</span> <span class="nv">duckdb_value_string_internal</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">row
</span>);
</code></pre></div></div>

#### Parameters

---
* `DEPRECATED`

use duckdb_value_string_internal instead. This function does not work correctly if the string contains
null bytes.
* `returns`

The char* value at the specified location. ONLY works on VARCHAR columns and does not auto-cast.
If the column is NOT a VARCHAR column this function will return NULL.

The result must NOT be freed.

<br>


### `duckdb_value_blob`

---

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_blob</span> <span class="nv">duckdb_value_blob</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">row
</span>);
</code></pre></div></div>

#### Parameters

---
* `returns`

The duckdb_blob value at the specified location. Returns a blob with blob.data set to nullptr if the
value cannot be converted. The resulting "blob.data" must be freed with `duckdb_free.`

<br>


### `duckdb_value_is_null`

---

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nv">duckdb_value_is_null</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">row
</span>);
</code></pre></div></div>

#### Parameters

---
* `returns`

Returns true if the value at the specified index is NULL, and false otherwise.

<br>


### `duckdb_malloc`

---
Allocate `size` bytes of memory using the duckdb internal malloc function. Any memory allocated in this manner
should be freed using `duckdb_free`.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> *<span class="nv">duckdb_malloc</span>(<span class="nv">
</span>  <span class="kt">size_t</span> <span class="nv">size
</span>);
</code></pre></div></div>

#### Parameters

---
* `size`

The number of bytes to allocate.
* `returns`

A pointer to the allocated memory region.

<br>


### `duckdb_free`

---
Free a value returned from `duckdb_malloc`, `duckdb_value_varchar` or `duckdb_value_blob`.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_free</span>(<span class="nv">
</span>  <span class="kt">void</span> *<span class="nv">ptr
</span>);
</code></pre></div></div>

#### Parameters

---
* `ptr`

The memory region to de-allocate.

<br>


### `duckdb_vector_size`

---
The internal vector size used by DuckDB.
This is the amount of tuples that will fit into a data chunk created by `duckdb_create_data_chunk`.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">idx_t</span> <span class="nv">duckdb_vector_size</span>(<span class="nv">
</span>  <span class="nv">
</span>);
</code></pre></div></div>

#### Parameters

---
* `returns`

The vector size.

<br>


### `duckdb_string_is_inlined`

---
Whether or not the duckdb_string_t value is inlined.
This means that the data of the string does not have a separate allocation.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nv">duckdb_string_is_inlined</span>(<span class="nv">
</span>  <span class="nv">duckdb_string_t</span> <span class="nv">string
</span>);
</code></pre></div></div>
<br>


### `duckdb_from_date`

---
Decompose a `duckdb_date` object into year, month and date (stored as `duckdb_date_struct`).

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_date_struct</span> <span class="nv">duckdb_from_date</span>(<span class="nv">
</span>  <span class="kt">duckdb_date</span> <span class="nv">date
</span>);
</code></pre></div></div>

#### Parameters

---
* `date`

The date object, as obtained from a `DUCKDB_TYPE_DATE` column.
* `returns`

The `duckdb_date_struct` with the decomposed elements.

<br>


### `duckdb_to_date`

---
Re-compose a `duckdb_date` from year, month and date (`duckdb_date_struct`).

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_date</span> <span class="nv">duckdb_to_date</span>(<span class="nv">
</span>  <span class="kt">duckdb_date_struct</span> <span class="nv">date
</span>);
</code></pre></div></div>

#### Parameters

---
* `date`

The year, month and date stored in a `duckdb_date_struct`.
* `returns`

The `duckdb_date` element.

<br>


### `duckdb_is_finite_date`

---
Test a `duckdb_date` to see if it is a finite value.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nv">duckdb_is_finite_date</span>(<span class="nv">
</span>  <span class="kt">duckdb_date</span> <span class="nv">date
</span>);
</code></pre></div></div>

#### Parameters

---
* `date`

The date object, as obtained from a `DUCKDB_TYPE_DATE` column.
* `returns`

True if the date is finite, false if it is ±infinity.

<br>


### `duckdb_from_time`

---
Decompose a `duckdb_time` object into hour, minute, second and microsecond (stored as `duckdb_time_struct`).

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_time_struct</span> <span class="nv">duckdb_from_time</span>(<span class="nv">
</span>  <span class="kt">duckdb_time</span> <span class="nv">time
</span>);
</code></pre></div></div>

#### Parameters

---
* `time`

The time object, as obtained from a `DUCKDB_TYPE_TIME` column.
* `returns`

The `duckdb_time_struct` with the decomposed elements.

<br>


### `duckdb_to_time`

---
Re-compose a `duckdb_time` from hour, minute, second and microsecond (`duckdb_time_struct`).

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_time</span> <span class="nv">duckdb_to_time</span>(<span class="nv">
</span>  <span class="kt">duckdb_time_struct</span> <span class="nv">time
</span>);
</code></pre></div></div>

#### Parameters

---
* `time`

The hour, minute, second and microsecond in a `duckdb_time_struct`.
* `returns`

The `duckdb_time` element.

<br>


### `duckdb_from_timestamp`

---
Decompose a `duckdb_timestamp` object into a `duckdb_timestamp_struct`.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_timestamp_struct</span> <span class="nv">duckdb_from_timestamp</span>(<span class="nv">
</span>  <span class="kt">duckdb_timestamp</span> <span class="nv">ts
</span>);
</code></pre></div></div>

#### Parameters

---
* `ts`

The ts object, as obtained from a `DUCKDB_TYPE_TIMESTAMP` column.
* `returns`

The `duckdb_timestamp_struct` with the decomposed elements.

<br>


### `duckdb_to_timestamp`

---
Re-compose a `duckdb_timestamp` from a duckdb_timestamp_struct.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_timestamp</span> <span class="nv">duckdb_to_timestamp</span>(<span class="nv">
</span>  <span class="kt">duckdb_timestamp_struct</span> <span class="nv">ts
</span>);
</code></pre></div></div>

#### Parameters

---
* `ts`

The de-composed elements in a `duckdb_timestamp_struct`.
* `returns`

The `duckdb_timestamp` element.

<br>


### `duckdb_is_finite_timestamp`

---
Test a `duckdb_timestamp` to see if it is a finite value.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nv">duckdb_is_finite_timestamp</span>(<span class="nv">
</span>  <span class="kt">duckdb_timestamp</span> <span class="nv">ts
</span>);
</code></pre></div></div>

#### Parameters

---
* `ts`

The timestamp object, as obtained from a `DUCKDB_TYPE_TIMESTAMP` column.
* `returns`

True if the timestamp is finite, false if it is ±infinity.

<br>


### `duckdb_hugeint_to_double`

---
Converts a duckdb_hugeint object (as obtained from a `DUCKDB_TYPE_HUGEINT` column) into a double.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="nv">duckdb_hugeint_to_double</span>(<span class="nv">
</span>  <span class="kt">duckdb_hugeint</span> <span class="nv">val
</span>);
</code></pre></div></div>

#### Parameters

---
* `val`

The hugeint value.
* `returns`

The converted `double` element.

<br>


### `duckdb_double_to_hugeint`

---
Converts a double value to a duckdb_hugeint object.

If the conversion fails because the double value is too big the result will be 0.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_hugeint</span> <span class="nv">duckdb_double_to_hugeint</span>(<span class="nv">
</span>  <span class="kt">double</span> <span class="nv">val
</span>);
</code></pre></div></div>

#### Parameters

---
* `val`

The double value.
* `returns`

The converted `duckdb_hugeint` element.

<br>


### `duckdb_double_to_decimal`

---
Converts a double value to a duckdb_decimal object.

If the conversion fails because the double value is too big, or the width/scale are invalid the result will be 0.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">duckdb_decimal</span> <span class="nv">duckdb_double_to_decimal</span>(<span class="nv">
</span>  <span class="kt">double</span> <span class="nv">val</span>,<span class="nv">
</span>  <span class="kt">uint8_t</span> <span class="nv">width</span>,<span class="nv">
</span>  <span class="kt">uint8_t</span> <span class="nv">scale
</span>);
</code></pre></div></div>

#### Parameters

---
* `val`

The double value.
* `returns`

The converted `duckdb_decimal` element.

<br>


### `duckdb_uhugeint_to_double`

---
Converts a duckdb_uhugeint object (as obtained from a `DUCKDB_TYPE_UHUGEINT` column) into a double.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="nv">duckdb_uhugeint_to_double</span>(<span class="nv">
</span>  <span class="nv">duckdb_uhugeint</span> <span class="nv">val
</span>);
</code></pre></div></div>

#### Parameters

---
* `val`

The uhugeint value.
* `returns`

The converted `double` element.

<br>


### `duckdb_double_to_uhugeint`

---
Converts a double value to a duckdb_uhugeint object.

If the conversion fails because the double value is too big the result will be 0.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">duckdb_uhugeint</span> <span class="nv">duckdb_double_to_uhugeint</span>(<span class="nv">
</span>  <span class="kt">double</span> <span class="nv">val
</span>);
</code></pre></div></div>

#### Parameters

---
* `val`

The double value.
* `returns`

The converted `duckdb_uhugeint` element.

<br>


### `duckdb_decimal_to_double`

---
Converts a duckdb_decimal object (as obtained from a `DUCKDB_TYPE_DECIMAL` column) into a double.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="nv">duckdb_decimal_to_double</span>(<span class="nv">
</span>  <span class="nv">duckdb_decimal</span> <span class="nv">val
</span>);
</code></pre></div></div>

#### Parameters

---
* `val`

The decimal value.
* `returns`

The converted `double` element.

<br>


### `duckdb_prepare`

---
Create a prepared statement object from a query.

Note that after calling `duckdb_prepare`, the prepared statement should always be destroyed using
`duckdb_destroy_prepare`, even if the prepare fails.

If the prepare fails, `duckdb_prepare_error` can be called to obtain the reason why the prepare failed.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_prepare</span>(<span class="nv">
</span>  <span class="kt">duckdb_connection</span> <span class="nv">connection</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">query</span>,<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> *<span class="nv">out_prepared_statement
</span>);
</code></pre></div></div>

#### Parameters

---
* `connection`

The connection object
* `query`

The SQL query to prepare
* `out_prepared_statement`

The resulting prepared statement object
* `returns`

`DuckDBSuccess` on success or `DuckDBError` on failure.

<br>


### `duckdb_destroy_prepare`

---
Closes the prepared statement and de-allocates all memory allocated for the statement.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_destroy_prepare</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> *<span class="nv">prepared_statement
</span>);
</code></pre></div></div>

#### Parameters

---
* `prepared_statement`

The prepared statement to destroy.

<br>


### `duckdb_prepare_error`

---
Returns the error message associated with the given prepared statement.
If the prepared statement has no error message, this returns `nullptr` instead.

The error message should not be freed. It will be de-allocated when `duckdb_destroy_prepare` is called.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">const</span> <span class="kt">char</span> *<span class="nv">duckdb_prepare_error</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement
</span>);
</code></pre></div></div>

#### Parameters

---
* `prepared_statement`

The prepared statement to obtain the error from.
* `returns`

The error message, or `nullptr` if there is none.

<br>


### `duckdb_nparams`

---
Returns the number of parameters that can be provided to the given prepared statement.

Returns 0 if the query was not successfully prepared.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">idx_t</span> <span class="nv">duckdb_nparams</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement
</span>);
</code></pre></div></div>

#### Parameters

---
* `prepared_statement`

The prepared statement to obtain the number of parameters for.

<br>


### `duckdb_parameter_name`

---
Returns the name used to identify the parameter
The returned string should be freed using `duckdb_free`.

Returns NULL if the index is out of range for the provided prepared statement.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">const</span> <span class="kt">char</span> *<span class="nv">duckdb_parameter_name</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">index
</span>);
</code></pre></div></div>

#### Parameters

---
* `prepared_statement`

The prepared statement for which to get the parameter name from.

<br>


### `duckdb_param_type`

---
Returns the parameter type for the parameter at the given index.

Returns `DUCKDB_TYPE_INVALID` if the parameter index is out of range or the statement was not successfully prepared.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">duckdb_type</span> <span class="nv">duckdb_param_type</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">param_idx
</span>);
</code></pre></div></div>

#### Parameters

---
* `prepared_statement`

The prepared statement.
* `param_idx`

The parameter index.
* `returns`

The parameter type

<br>


### `duckdb_clear_bindings`

---
Clear the params bind to the prepared statement.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_clear_bindings</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement
</span>);
</code></pre></div></div>
<br>


### `duckdb_prepared_statement_type`

---
Returns the statement type of the statement to be executed

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">duckdb_statement_type</span> <span class="nv">duckdb_prepared_statement_type</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">statement
</span>);
</code></pre></div></div>

#### Parameters

---
* `statement`

The prepared statement.
* `returns`

duckdb_statement_type value or DUCKDB_STATEMENT_TYPE_INVALID

<br>


### `duckdb_bind_value`

---
Binds a value to the prepared statement at the specified index.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_bind_value</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">param_idx</span>,<span class="nv">
</span>  <span class="kt">duckdb_value</span> <span class="nv">val
</span>);
</code></pre></div></div>
<br>


### `duckdb_bind_parameter_index`

---
Retrieve the index of the parameter for the prepared statement, identified by name

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_bind_parameter_index</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> *<span class="nv">param_idx_out</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">name
</span>);
</code></pre></div></div>
<br>


### `duckdb_bind_boolean`

---
Binds a bool value to the prepared statement at the specified index.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_bind_boolean</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">param_idx</span>,<span class="nv">
</span>  <span class="kt">bool</span> <span class="nv">val
</span>);
</code></pre></div></div>
<br>


### `duckdb_bind_int8`

---
Binds an int8_t value to the prepared statement at the specified index.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_bind_int8</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">param_idx</span>,<span class="nv">
</span>  <span class="kt">int8_t</span> <span class="nv">val
</span>);
</code></pre></div></div>
<br>


### `duckdb_bind_int16`

---
Binds an int16_t value to the prepared statement at the specified index.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_bind_int16</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">param_idx</span>,<span class="nv">
</span>  <span class="kt">int16_t</span> <span class="nv">val
</span>);
</code></pre></div></div>
<br>


### `duckdb_bind_int32`

---
Binds an int32_t value to the prepared statement at the specified index.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_bind_int32</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">param_idx</span>,<span class="nv">
</span>  <span class="kt">int32_t</span> <span class="nv">val
</span>);
</code></pre></div></div>
<br>


### `duckdb_bind_int64`

---
Binds an int64_t value to the prepared statement at the specified index.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_bind_int64</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">param_idx</span>,<span class="nv">
</span>  <span class="kt">int64_t</span> <span class="nv">val
</span>);
</code></pre></div></div>
<br>


### `duckdb_bind_hugeint`

---
Binds a duckdb_hugeint value to the prepared statement at the specified index.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_bind_hugeint</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">param_idx</span>,<span class="nv">
</span>  <span class="kt">duckdb_hugeint</span> <span class="nv">val
</span>);
</code></pre></div></div>
<br>


### `duckdb_bind_uhugeint`

---
Binds an duckdb_uhugeint value to the prepared statement at the specified index.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_bind_uhugeint</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">param_idx</span>,<span class="nv">
</span>  <span class="nv">duckdb_uhugeint</span> <span class="nv">val
</span>);
</code></pre></div></div>
<br>


### `duckdb_bind_decimal`

---
Binds a duckdb_decimal value to the prepared statement at the specified index.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_bind_decimal</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">param_idx</span>,<span class="nv">
</span>  <span class="nv">duckdb_decimal</span> <span class="nv">val
</span>);
</code></pre></div></div>
<br>


### `duckdb_bind_uint8`

---
Binds an uint8_t value to the prepared statement at the specified index.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_bind_uint8</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">param_idx</span>,<span class="nv">
</span>  <span class="kt">uint8_t</span> <span class="nv">val
</span>);
</code></pre></div></div>
<br>


### `duckdb_bind_uint16`

---
Binds an uint16_t value to the prepared statement at the specified index.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_bind_uint16</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">param_idx</span>,<span class="nv">
</span>  <span class="kt">uint16_t</span> <span class="nv">val
</span>);
</code></pre></div></div>
<br>


### `duckdb_bind_uint32`

---
Binds an uint32_t value to the prepared statement at the specified index.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_bind_uint32</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">param_idx</span>,<span class="nv">
</span>  <span class="kt">uint32_t</span> <span class="nv">val
</span>);
</code></pre></div></div>
<br>


### `duckdb_bind_uint64`

---
Binds an uint64_t value to the prepared statement at the specified index.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_bind_uint64</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">param_idx</span>,<span class="nv">
</span>  <span class="kt">uint64_t</span> <span class="nv">val
</span>);
</code></pre></div></div>
<br>


### `duckdb_bind_float`

---
Binds a float value to the prepared statement at the specified index.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_bind_float</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">param_idx</span>,<span class="nv">
</span>  <span class="kt">float</span> <span class="nv">val
</span>);
</code></pre></div></div>
<br>


### `duckdb_bind_double`

---
Binds a double value to the prepared statement at the specified index.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_bind_double</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">param_idx</span>,<span class="nv">
</span>  <span class="kt">double</span> <span class="nv">val
</span>);
</code></pre></div></div>
<br>


### `duckdb_bind_date`

---
Binds a duckdb_date value to the prepared statement at the specified index.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_bind_date</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">param_idx</span>,<span class="nv">
</span>  <span class="kt">duckdb_date</span> <span class="nv">val
</span>);
</code></pre></div></div>
<br>


### `duckdb_bind_time`

---
Binds a duckdb_time value to the prepared statement at the specified index.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_bind_time</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">param_idx</span>,<span class="nv">
</span>  <span class="kt">duckdb_time</span> <span class="nv">val
</span>);
</code></pre></div></div>
<br>


### `duckdb_bind_timestamp`

---
Binds a duckdb_timestamp value to the prepared statement at the specified index.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_bind_timestamp</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">param_idx</span>,<span class="nv">
</span>  <span class="kt">duckdb_timestamp</span> <span class="nv">val
</span>);
</code></pre></div></div>
<br>


### `duckdb_bind_interval`

---
Binds a duckdb_interval value to the prepared statement at the specified index.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_bind_interval</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">param_idx</span>,<span class="nv">
</span>  <span class="kt">duckdb_interval</span> <span class="nv">val
</span>);
</code></pre></div></div>
<br>


### `duckdb_bind_varchar`

---
Binds a null-terminated varchar value to the prepared statement at the specified index.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_bind_varchar</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">param_idx</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">val
</span>);
</code></pre></div></div>
<br>


### `duckdb_bind_varchar_length`

---
Binds a varchar value to the prepared statement at the specified index.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_bind_varchar_length</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">param_idx</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">val</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">length
</span>);
</code></pre></div></div>
<br>


### `duckdb_bind_blob`

---
Binds a blob value to the prepared statement at the specified index.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_bind_blob</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">param_idx</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">void</span> *<span class="nv">data</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">length
</span>);
</code></pre></div></div>
<br>


### `duckdb_bind_null`

---
Binds a NULL value to the prepared statement at the specified index.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_bind_null</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">param_idx
</span>);
</code></pre></div></div>
<br>


### `duckdb_execute_prepared`

---
Executes the prepared statement with the given bound parameters, and returns a materialized query result.

This method can be called multiple times for each prepared statement, and the parameters can be modified
between calls to this function.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_execute_prepared</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">out_result
</span>);
</code></pre></div></div>

#### Parameters

---
* `prepared_statement`

The prepared statement to execute.
* `out_result`

The query result.
* `returns`

`DuckDBSuccess` on success or `DuckDBError` on failure.

<br>


### `duckdb_execute_prepared_streaming`

---
Executes the prepared statement with the given bound parameters, and returns an optionally-streaming query result.
To determine if the resulting query was in fact streamed, use `duckdb_result_is_streaming`

This method can be called multiple times for each prepared statement, and the parameters can be modified
between calls to this function.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_execute_prepared_streaming</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">out_result
</span>);
</code></pre></div></div>

#### Parameters

---
* `prepared_statement`

The prepared statement to execute.
* `out_result`

The query result.
* `returns`

`DuckDBSuccess` on success or `DuckDBError` on failure.

<br>


### `duckdb_execute_prepared_arrow`

---
Executes the prepared statement with the given bound parameters, and returns an arrow query result.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_execute_prepared_arrow</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="kt">duckdb_arrow</span> *<span class="nv">out_result
</span>);
</code></pre></div></div>

#### Parameters

---
* `prepared_statement`

The prepared statement to execute.
* `out_result`

The query result.
* `returns`

`DuckDBSuccess` on success or `DuckDBError` on failure.

<br>


### `duckdb_arrow_scan`

---
Scans the Arrow stream and creates a view with the given name.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_arrow_scan</span>(<span class="nv">
</span>  <span class="kt">duckdb_connection</span> <span class="nv">connection</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">table_name</span>,<span class="nv">
</span>  <span class="nv">duckdb_arrow_stream</span> <span class="nv">arrow
</span>);
</code></pre></div></div>

#### Parameters

---
* `connection`

The connection on which to execute the scan.
* `table_name`

Name of the temporary view to create.
* `arrow`

Arrow stream wrapper.
* `returns`

`DuckDBSuccess` on success or `DuckDBError` on failure.

<br>


### `duckdb_arrow_array_scan`

---
Scans the Arrow array and creates a view with the given name.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_arrow_array_scan</span>(<span class="nv">
</span>  <span class="kt">duckdb_connection</span> <span class="nv">connection</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">table_name</span>,<span class="nv">
</span>  <span class="kt">duckdb_arrow_schema</span> <span class="nv">arrow_schema</span>,<span class="nv">
</span>  <span class="kt">duckdb_arrow_array</span> <span class="nv">arrow_array</span>,<span class="nv">
</span>  <span class="nv">duckdb_arrow_stream</span> *<span class="nv">out_stream
</span>);
</code></pre></div></div>

#### Parameters

---
* `connection`

The connection on which to execute the scan.
* `table_name`

Name of the temporary view to create.
* `arrow_schema`

Arrow schema wrapper.
* `arrow_array`

Arrow array wrapper.
* `out_stream`

Output array stream that wraps around the passed schema, for releasing/deleting once done.
* `returns`

`DuckDBSuccess` on success or `DuckDBError` on failure.

<br>


### `duckdb_extract_statements`

---
Extract all statements from a query.
Note that after calling `duckdb_extract_statements`, the extracted statements should always be destroyed using
`duckdb_destroy_extracted`, even if no statements were extracted.
If the extract fails, `duckdb_extract_statements_error` can be called to obtain the reason why the extract failed.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">idx_t</span> <span class="nv">duckdb_extract_statements</span>(<span class="nv">
</span>  <span class="kt">duckdb_connection</span> <span class="nv">connection</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">query</span>,<span class="nv">
</span>  <span class="nv">duckdb_extracted_statements</span> *<span class="nv">out_extracted_statements
</span>);
</code></pre></div></div>

#### Parameters

---
* `connection`

The connection object
* `query`

The SQL query to extract
* `out_extracted_statements`

The resulting extracted statements object
* `returns`

The number of extracted statements or 0 on failure.

<br>


### `duckdb_prepare_extracted_statement`

---
Prepare an extracted statement.
Note that after calling `duckdb_prepare_extracted_statement`, the prepared statement should always be destroyed using
`duckdb_destroy_prepare`, even if the prepare fails.
If the prepare fails, `duckdb_prepare_error` can be called to obtain the reason why the prepare failed.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_prepare_extracted_statement</span>(<span class="nv">
</span>  <span class="kt">duckdb_connection</span> <span class="nv">connection</span>,<span class="nv">
</span>  <span class="nv">duckdb_extracted_statements</span> <span class="nv">extracted_statements</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">index</span>,<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> *<span class="nv">out_prepared_statement
</span>);
</code></pre></div></div>

#### Parameters

---
* `connection`

The connection object
* `extracted_statements`

The extracted statements object
* `index`

The index of the extracted statement to prepare
* `out_prepared_statement`

The resulting prepared statement object
* `returns`

`DuckDBSuccess` on success or `DuckDBError` on failure.

<br>


### `duckdb_extract_statements_error`

---
Returns the error message contained within the extracted statements.
The result of this function must not be freed. It will be cleaned up when `duckdb_destroy_extracted` is called.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">const</span> <span class="kt">char</span> *<span class="nv">duckdb_extract_statements_error</span>(<span class="nv">
</span>  <span class="nv">duckdb_extracted_statements</span> <span class="nv">extracted_statements
</span>);
</code></pre></div></div>

#### Parameters

---
* `result`

The extracted statements to fetch the error from.
* `returns`

The error of the extracted statements.

<br>


### `duckdb_destroy_extracted`

---
De-allocates all memory allocated for the extracted statements.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_destroy_extracted</span>(<span class="nv">
</span>  <span class="nv">duckdb_extracted_statements</span> *<span class="nv">extracted_statements
</span>);
</code></pre></div></div>

#### Parameters

---
* `extracted_statements`

The extracted statements to destroy.

<br>


### `duckdb_pending_prepared`

---
Executes the prepared statement with the given bound parameters, and returns a pending result.
The pending result represents an intermediate structure for a query that is not yet fully executed.
The pending result can be used to incrementally execute a query, returning control to the client between tasks.

Note that after calling `duckdb_pending_prepared`, the pending result should always be destroyed using
`duckdb_destroy_pending`, even if this function returns DuckDBError.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_pending_prepared</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="nv">duckdb_pending_result</span> *<span class="nv">out_result
</span>);
</code></pre></div></div>

#### Parameters

---
* `prepared_statement`

The prepared statement to execute.
* `out_result`

The pending query result.
* `returns`

`DuckDBSuccess` on success or `DuckDBError` on failure.

<br>


### `duckdb_pending_prepared_streaming`

---
Executes the prepared statement with the given bound parameters, and returns a pending result.
This pending result will create a streaming duckdb_result when executed.
The pending result represents an intermediate structure for a query that is not yet fully executed.

Note that after calling `duckdb_pending_prepared_streaming`, the pending result should always be destroyed using
`duckdb_destroy_pending`, even if this function returns DuckDBError.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_pending_prepared_streaming</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared_statement</span>,<span class="nv">
</span>  <span class="nv">duckdb_pending_result</span> *<span class="nv">out_result
</span>);
</code></pre></div></div>

#### Parameters

---
* `prepared_statement`

The prepared statement to execute.
* `out_result`

The pending query result.
* `returns`

`DuckDBSuccess` on success or `DuckDBError` on failure.

<br>


### `duckdb_destroy_pending`

---
Closes the pending result and de-allocates all memory allocated for the result.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_destroy_pending</span>(<span class="nv">
</span>  <span class="nv">duckdb_pending_result</span> *<span class="nv">pending_result
</span>);
</code></pre></div></div>

#### Parameters

---
* `pending_result`

The pending result to destroy.

<br>


### `duckdb_pending_error`

---
Returns the error message contained within the pending result.

The result of this function must not be freed. It will be cleaned up when `duckdb_destroy_pending` is called.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">const</span> <span class="kt">char</span> *<span class="nv">duckdb_pending_error</span>(<span class="nv">
</span>  <span class="nv">duckdb_pending_result</span> <span class="nv">pending_result
</span>);
</code></pre></div></div>

#### Parameters

---
* `result`

The pending result to fetch the error from.
* `returns`

The error of the pending result.

<br>


### `duckdb_pending_execute_task`

---
Executes a single task within the query, returning whether or not the query is ready.

If this returns DUCKDB_PENDING_RESULT_READY, the duckdb_execute_pending function can be called to obtain the result.
If this returns DUCKDB_PENDING_RESULT_NOT_READY, the duckdb_pending_execute_task function should be called again.
If this returns DUCKDB_PENDING_ERROR, an error occurred during execution.

The error message can be obtained by calling duckdb_pending_error on the pending_result.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">duckdb_pending_state</span> <span class="nv">duckdb_pending_execute_task</span>(<span class="nv">
</span>  <span class="nv">duckdb_pending_result</span> <span class="nv">pending_result
</span>);
</code></pre></div></div>

#### Parameters

---
* `pending_result`

The pending result to execute a task within..
* `returns`

The state of the pending result after the execution.

<br>


### `duckdb_execute_pending`

---
Fully execute a pending query result, returning the final query result.

If duckdb_pending_execute_task has been called until DUCKDB_PENDING_RESULT_READY was returned, this will return fast.
Otherwise, all remaining tasks must be executed first.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_execute_pending</span>(<span class="nv">
</span>  <span class="nv">duckdb_pending_result</span> <span class="nv">pending_result</span>,<span class="nv">
</span>  <span class="kt">duckdb_result</span> *<span class="nv">out_result
</span>);
</code></pre></div></div>

#### Parameters

---
* `pending_result`

The pending result to execute.
* `out_result`

The result object.
* `returns`

`DuckDBSuccess` on success or `DuckDBError` on failure.

<br>


### `duckdb_pending_execution_is_finished`

---
Returns whether a duckdb_pending_state is finished executing. For example if `pending_state` is
DUCKDB_PENDING_RESULT_READY, this function will return true.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nv">duckdb_pending_execution_is_finished</span>(<span class="nv">
</span>  <span class="nv">duckdb_pending_state</span> <span class="nv">pending_state
</span>);
</code></pre></div></div>

#### Parameters

---
* `pending_state`

The pending state on which to decide whether to finish execution.
* `returns`

Boolean indicating pending execution should be considered finished.

<br>


### `duckdb_destroy_value`

---
Destroys the value and de-allocates all memory allocated for that type.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_destroy_value</span>(<span class="nv">
</span>  <span class="kt">duckdb_value</span> *<span class="nv">value
</span>);
</code></pre></div></div>

#### Parameters

---
* `value`

The value to destroy.

<br>


### `duckdb_create_varchar`

---
Creates a value from a null-terminated string

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_value</span> <span class="nv">duckdb_create_varchar</span>(<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">text
</span>);
</code></pre></div></div>

#### Parameters

---
* `value`

The null-terminated string
* `returns`

The value. This must be destroyed with `duckdb_destroy_value`.

<br>


### `duckdb_create_varchar_length`

---
Creates a value from a string

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_value</span> <span class="nv">duckdb_create_varchar_length</span>(<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">text</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">length
</span>);
</code></pre></div></div>

#### Parameters

---
* `value`

The text
* `length`

The length of the text
* `returns`

The value. This must be destroyed with `duckdb_destroy_value`.

<br>


### `duckdb_create_int64`

---
Creates a value from an int64

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_value</span> <span class="nv">duckdb_create_int64</span>(<span class="nv">
</span>  <span class="kt">int64_t</span> <span class="nv">val
</span>);
</code></pre></div></div>

#### Parameters

---
* `value`

The bigint value
* `returns`

The value. This must be destroyed with `duckdb_destroy_value`.

<br>


### `duckdb_create_struct_value`

---
Creates a struct value from a type and an array of values

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_value</span> <span class="nv">duckdb_create_struct_value</span>(<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> <span class="nv">type</span>,<span class="nv">
</span>  <span class="kt">duckdb_value</span> *<span class="nv">values
</span>);
</code></pre></div></div>

#### Parameters

---
* `type`

The type of the struct
* `values`

The values for the struct fields
* `returns`

The value. This must be destroyed with `duckdb_destroy_value`.

<br>


### `duckdb_create_list_value`

---
Creates a list value from a type and an array of values of length `value_count`

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_value</span> <span class="nv">duckdb_create_list_value</span>(<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> <span class="nv">type</span>,<span class="nv">
</span>  <span class="kt">duckdb_value</span> *<span class="nv">values</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">value_count
</span>);
</code></pre></div></div>

#### Parameters

---
* `type`

The type of the list
* `values`

The values for the list
* `value_count`

The number of values in the list
* `returns`

The value. This must be destroyed with `duckdb_destroy_value`.

<br>


### `duckdb_get_varchar`

---
Obtains a string representation of the given value.
The result must be destroyed with `duckdb_free`.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> *<span class="nv">duckdb_get_varchar</span>(<span class="nv">
</span>  <span class="kt">duckdb_value</span> <span class="nv">value
</span>);
</code></pre></div></div>

#### Parameters

---
* `value`

The value
* `returns`

The string value. This must be destroyed with `duckdb_free`.

<br>


### `duckdb_get_int64`

---
Obtains an int64 of the given value.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int64_t</span> <span class="nv">duckdb_get_int64</span>(<span class="nv">
</span>  <span class="kt">duckdb_value</span> <span class="nv">value
</span>);
</code></pre></div></div>

#### Parameters

---
* `value`

The value
* `returns`

The int64 value, or 0 if no conversion is possible

<br>


### `duckdb_create_logical_type`

---
Creates a `duckdb_logical_type` from a standard primitive type.
The resulting type should be destroyed with `duckdb_destroy_logical_type`.

This should not be used with `DUCKDB_TYPE_DECIMAL`.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_logical_type</span> <span class="nv">duckdb_create_logical_type</span>(<span class="nv">
</span>  <span class="nv">duckdb_type</span> <span class="nv">type
</span>);
</code></pre></div></div>

#### Parameters

---
* `type`

The primitive type to create.
* `returns`

The logical type.

<br>


### `duckdb_logical_type_get_alias`

---
Returns the alias of a duckdb_logical_type, if one is set, else `NULL`
You must free the result.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> *<span class="nv">duckdb_logical_type_get_alias</span>(<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> <span class="nv">type
</span>);
</code></pre></div></div>

#### Parameters

---
* `type`

The logical type to return the alias of
* `returns`

The alias or `NULL`

<br>


### `duckdb_create_list_type`

---
Creates a list type from its child type.
The resulting type should be destroyed with `duckdb_destroy_logical_type`.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_logical_type</span> <span class="nv">duckdb_create_list_type</span>(<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> <span class="nv">type
</span>);
</code></pre></div></div>

#### Parameters

---
* `type`

The child type of list type to create.
* `returns`

The logical type.

<br>


### `duckdb_create_map_type`

---
Creates a map type from its key type and value type.
The resulting type should be destroyed with `duckdb_destroy_logical_type`.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_logical_type</span> <span class="nv">duckdb_create_map_type</span>(<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> <span class="nv">key_type</span>,<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> <span class="nv">value_type
</span>);
</code></pre></div></div>

#### Parameters

---
* `type`

The key type and value type of map type to create.
* `returns`

The logical type.

<br>


### `duckdb_create_union_type`

---
Creates a UNION type from the passed types array
The resulting type should be destroyed with `duckdb_destroy_logical_type`.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_logical_type</span> <span class="nv">duckdb_create_union_type</span>(<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> *<span class="nv">member_types</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> **<span class="nv">member_names</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">member_count
</span>);
</code></pre></div></div>

#### Parameters

---
* `types`

The array of types that the union should consist of.
* `type_amount`

The size of the types array.
* `returns`

The logical type.

<br>


### `duckdb_create_struct_type`

---
Creates a STRUCT type from the passed member name and type arrays.
The resulting type should be destroyed with `duckdb_destroy_logical_type`.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_logical_type</span> <span class="nv">duckdb_create_struct_type</span>(<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> *<span class="nv">member_types</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> **<span class="nv">member_names</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">member_count
</span>);
</code></pre></div></div>

#### Parameters

---
* `member_types`

The array of types that the struct should consist of.
* `member_names`

The array of names that the struct should consist of.
* `member_count`

The number of members that were specified for both arrays.
* `returns`

The logical type.

<br>


### `duckdb_create_enum_type`

---
Creates an ENUM type from the passed member name array.
The resulting type should be destroyed with `duckdb_destroy_logical_type`.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_logical_type</span> <span class="nv">duckdb_create_enum_type</span>(<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> **<span class="nv">member_names</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">member_count
</span>);
</code></pre></div></div>

#### Parameters

---
* `enum_name`

The name of the enum.
* `member_names`

The array of names that the enum should consist of.
* `member_count`

The number of elements that were specified in the array.
* `returns`

The logical type.

<br>


### `duckdb_create_decimal_type`

---
Creates a `duckdb_logical_type` of type decimal with the specified width and scale
The resulting type should be destroyed with `duckdb_destroy_logical_type`.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_logical_type</span> <span class="nv">duckdb_create_decimal_type</span>(<span class="nv">
</span>  <span class="kt">uint8_t</span> <span class="nv">width</span>,<span class="nv">
</span>  <span class="kt">uint8_t</span> <span class="nv">scale
</span>);
</code></pre></div></div>

#### Parameters

---
* `width`

The width of the decimal type
* `scale`

The scale of the decimal type
* `returns`

The logical type.

<br>


### `duckdb_get_type_id`

---
Retrieves the type class of a `duckdb_logical_type`.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">duckdb_type</span> <span class="nv">duckdb_get_type_id</span>(<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> <span class="nv">type
</span>);
</code></pre></div></div>

#### Parameters

---
* `type`

The logical type object
* `returns`

The type id

<br>


### `duckdb_decimal_width`

---
Retrieves the width of a decimal type.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint8_t</span> <span class="nv">duckdb_decimal_width</span>(<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> <span class="nv">type
</span>);
</code></pre></div></div>

#### Parameters

---
* `type`

The logical type object
* `returns`

The width of the decimal type

<br>


### `duckdb_decimal_scale`

---
Retrieves the scale of a decimal type.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint8_t</span> <span class="nv">duckdb_decimal_scale</span>(<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> <span class="nv">type
</span>);
</code></pre></div></div>

#### Parameters

---
* `type`

The logical type object
* `returns`

The scale of the decimal type

<br>


### `duckdb_decimal_internal_type`

---
Retrieves the internal storage type of a decimal type.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">duckdb_type</span> <span class="nv">duckdb_decimal_internal_type</span>(<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> <span class="nv">type
</span>);
</code></pre></div></div>

#### Parameters

---
* `type`

The logical type object
* `returns`

The internal type of the decimal type

<br>


### `duckdb_enum_internal_type`

---
Retrieves the internal storage type of an enum type.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">duckdb_type</span> <span class="nv">duckdb_enum_internal_type</span>(<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> <span class="nv">type
</span>);
</code></pre></div></div>

#### Parameters

---
* `type`

The logical type object
* `returns`

The internal type of the enum type

<br>


### `duckdb_enum_dictionary_size`

---
Retrieves the dictionary size of the enum type

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint32_t</span> <span class="nv">duckdb_enum_dictionary_size</span>(<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> <span class="nv">type
</span>);
</code></pre></div></div>

#### Parameters

---
* `type`

The logical type object
* `returns`

The dictionary size of the enum type

<br>


### `duckdb_enum_dictionary_value`

---
Retrieves the dictionary value at the specified position from the enum.

The result must be freed with `duckdb_free`

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> *<span class="nv">duckdb_enum_dictionary_value</span>(<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> <span class="nv">type</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">index
</span>);
</code></pre></div></div>

#### Parameters

---
* `type`

The logical type object
* `index`

The index in the dictionary
* `returns`

The string value of the enum type. Must be freed with `duckdb_free`.

<br>


### `duckdb_list_type_child_type`

---
Retrieves the child type of the given list type.

The result must be freed with `duckdb_destroy_logical_type`

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_logical_type</span> <span class="nv">duckdb_list_type_child_type</span>(<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> <span class="nv">type
</span>);
</code></pre></div></div>

#### Parameters

---
* `type`

The logical type object
* `returns`

The child type of the list type. Must be destroyed with `duckdb_destroy_logical_type`.

<br>


### `duckdb_map_type_key_type`

---
Retrieves the key type of the given map type.

The result must be freed with `duckdb_destroy_logical_type`

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_logical_type</span> <span class="nv">duckdb_map_type_key_type</span>(<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> <span class="nv">type
</span>);
</code></pre></div></div>

#### Parameters

---
* `type`

The logical type object
* `returns`

The key type of the map type. Must be destroyed with `duckdb_destroy_logical_type`.

<br>


### `duckdb_map_type_value_type`

---
Retrieves the value type of the given map type.

The result must be freed with `duckdb_destroy_logical_type`

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_logical_type</span> <span class="nv">duckdb_map_type_value_type</span>(<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> <span class="nv">type
</span>);
</code></pre></div></div>

#### Parameters

---
* `type`

The logical type object
* `returns`

The value type of the map type. Must be destroyed with `duckdb_destroy_logical_type`.

<br>


### `duckdb_struct_type_child_count`

---
Returns the number of children of a struct type.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">idx_t</span> <span class="nv">duckdb_struct_type_child_count</span>(<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> <span class="nv">type
</span>);
</code></pre></div></div>

#### Parameters

---
* `type`

The logical type object
* `returns`

The number of children of a struct type.

<br>


### `duckdb_struct_type_child_name`

---
Retrieves the name of the struct child.

The result must be freed with `duckdb_free`

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> *<span class="nv">duckdb_struct_type_child_name</span>(<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> <span class="nv">type</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">index
</span>);
</code></pre></div></div>

#### Parameters

---
* `type`

The logical type object
* `index`

The child index
* `returns`

The name of the struct type. Must be freed with `duckdb_free`.

<br>


### `duckdb_struct_type_child_type`

---
Retrieves the child type of the given struct type at the specified index.

The result must be freed with `duckdb_destroy_logical_type`

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_logical_type</span> <span class="nv">duckdb_struct_type_child_type</span>(<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> <span class="nv">type</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">index
</span>);
</code></pre></div></div>

#### Parameters

---
* `type`

The logical type object
* `index`

The child index
* `returns`

The child type of the struct type. Must be destroyed with `duckdb_destroy_logical_type`.

<br>


### `duckdb_union_type_member_count`

---
Returns the number of members that the union type has.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">idx_t</span> <span class="nv">duckdb_union_type_member_count</span>(<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> <span class="nv">type
</span>);
</code></pre></div></div>

#### Parameters

---
* `type`

The logical type (union) object
* `returns`

The number of members of a union type.

<br>


### `duckdb_union_type_member_name`

---
Retrieves the name of the union member.

The result must be freed with `duckdb_free`

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> *<span class="nv">duckdb_union_type_member_name</span>(<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> <span class="nv">type</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">index
</span>);
</code></pre></div></div>

#### Parameters

---
* `type`

The logical type object
* `index`

The child index
* `returns`

The name of the union member. Must be freed with `duckdb_free`.

<br>


### `duckdb_union_type_member_type`

---
Retrieves the child type of the given union member at the specified index.

The result must be freed with `duckdb_destroy_logical_type`

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_logical_type</span> <span class="nv">duckdb_union_type_member_type</span>(<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> <span class="nv">type</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">index
</span>);
</code></pre></div></div>

#### Parameters

---
* `type`

The logical type object
* `index`

The child index
* `returns`

The child type of the union member. Must be destroyed with `duckdb_destroy_logical_type`.

<br>


### `duckdb_destroy_logical_type`

---
Destroys the logical type and de-allocates all memory allocated for that type.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_destroy_logical_type</span>(<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> *<span class="nv">type
</span>);
</code></pre></div></div>

#### Parameters

---
* `type`

The logical type to destroy.

<br>


### `duckdb_create_data_chunk`

---
Creates an empty DataChunk with the specified set of types.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_data_chunk</span> <span class="nv">duckdb_create_data_chunk</span>(<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> *<span class="nv">types</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">column_count
</span>);
</code></pre></div></div>

#### Parameters

---
* `types`

An array of types of the data chunk.
* `column_count`

The number of columns.
* `returns`

The data chunk.

<br>


### `duckdb_destroy_data_chunk`

---
Destroys the data chunk and de-allocates all memory allocated for that chunk.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_destroy_data_chunk</span>(<span class="nv">
</span>  <span class="kt">duckdb_data_chunk</span> *<span class="nv">chunk
</span>);
</code></pre></div></div>

#### Parameters

---
* `chunk`

The data chunk to destroy.

<br>


### `duckdb_data_chunk_reset`

---
Resets a data chunk, clearing the validity masks and setting the cardinality of the data chunk to 0.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_data_chunk_reset</span>(<span class="nv">
</span>  <span class="kt">duckdb_data_chunk</span> <span class="nv">chunk
</span>);
</code></pre></div></div>

#### Parameters

---
* `chunk`

The data chunk to reset.

<br>


### `duckdb_data_chunk_get_column_count`

---
Retrieves the number of columns in a data chunk.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">idx_t</span> <span class="nv">duckdb_data_chunk_get_column_count</span>(<span class="nv">
</span>  <span class="kt">duckdb_data_chunk</span> <span class="nv">chunk
</span>);
</code></pre></div></div>

#### Parameters

---
* `chunk`

The data chunk to get the data from
* `returns`

The number of columns in the data chunk

<br>


### `duckdb_data_chunk_get_vector`

---
Retrieves the vector at the specified column index in the data chunk.

The pointer to the vector is valid for as long as the chunk is alive.
It does NOT need to be destroyed.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_vector</span> <span class="nv">duckdb_data_chunk_get_vector</span>(<span class="nv">
</span>  <span class="kt">duckdb_data_chunk</span> <span class="nv">chunk</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">col_idx
</span>);
</code></pre></div></div>

#### Parameters

---
* `chunk`

The data chunk to get the data from
* `returns`

The vector

<br>


### `duckdb_data_chunk_get_size`

---
Retrieves the current number of tuples in a data chunk.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">idx_t</span> <span class="nv">duckdb_data_chunk_get_size</span>(<span class="nv">
</span>  <span class="kt">duckdb_data_chunk</span> <span class="nv">chunk
</span>);
</code></pre></div></div>

#### Parameters

---
* `chunk`

The data chunk to get the data from
* `returns`

The number of tuples in the data chunk

<br>


### `duckdb_data_chunk_set_size`

---
Sets the current number of tuples in a data chunk.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_data_chunk_set_size</span>(<span class="nv">
</span>  <span class="kt">duckdb_data_chunk</span> <span class="nv">chunk</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">size
</span>);
</code></pre></div></div>

#### Parameters

---
* `chunk`

The data chunk to set the size in
* `size`

The number of tuples in the data chunk

<br>


### `duckdb_vector_get_column_type`

---
Retrieves the column type of the specified vector.

The result must be destroyed with `duckdb_destroy_logical_type`.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_logical_type</span> <span class="nv">duckdb_vector_get_column_type</span>(<span class="nv">
</span>  <span class="kt">duckdb_vector</span> <span class="nv">vector
</span>);
</code></pre></div></div>

#### Parameters

---
* `vector`

The vector get the data from
* `returns`

The type of the vector

<br>


### `duckdb_vector_get_data`

---
Retrieves the data pointer of the vector.

The data pointer can be used to read or write values from the vector.
How to read or write values depends on the type of the vector.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> *<span class="nv">duckdb_vector_get_data</span>(<span class="nv">
</span>  <span class="kt">duckdb_vector</span> <span class="nv">vector
</span>);
</code></pre></div></div>

#### Parameters

---
* `vector`

The vector to get the data from
* `returns`

The data pointer

<br>


### `duckdb_vector_get_validity`

---
Retrieves the validity mask pointer of the specified vector.

If all values are valid, this function MIGHT return NULL!

The validity mask is a bitset that signifies null-ness within the data chunk.
It is a series of uint64_t values, where each uint64_t value contains validity for 64 tuples.
The bit is set to 1 if the value is valid (i.e., not NULL) or 0 if the value is invalid (i.e., NULL).

Validity of a specific value can be obtained like this:

idx_t entry_idx = row_idx / 64;
idx_t idx_in_entry = row_idx % 64;
bool is_valid = validity_mask[entry_idx] & (1 << idx_in_entry);

Alternatively, the (slower) duckdb_validity_row_is_valid function can be used.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> *<span class="nv">duckdb_vector_get_validity</span>(<span class="nv">
</span>  <span class="kt">duckdb_vector</span> <span class="nv">vector
</span>);
</code></pre></div></div>

#### Parameters

---
* `vector`

The vector to get the data from
* `returns`

The pointer to the validity mask, or NULL if no validity mask is present

<br>


### `duckdb_vector_ensure_validity_writable`

---
Ensures the validity mask is writable by allocating it.

After this function is called, `duckdb_vector_get_validity` will ALWAYS return non-NULL.
This allows null values to be written to the vector, regardless of whether a validity mask was present before.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_vector_ensure_validity_writable</span>(<span class="nv">
</span>  <span class="kt">duckdb_vector</span> <span class="nv">vector
</span>);
</code></pre></div></div>

#### Parameters

---
* `vector`

The vector to alter

<br>


### `duckdb_vector_assign_string_element`

---
Assigns a string element in the vector at the specified location.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_vector_assign_string_element</span>(<span class="nv">
</span>  <span class="kt">duckdb_vector</span> <span class="nv">vector</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">index</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">str
</span>);
</code></pre></div></div>

#### Parameters

---
* `vector`

The vector to alter
* `index`

The row position in the vector to assign the string to
* `str`

The null-terminated string

<br>


### `duckdb_vector_assign_string_element_len`

---
Assigns a string element in the vector at the specified location.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_vector_assign_string_element_len</span>(<span class="nv">
</span>  <span class="kt">duckdb_vector</span> <span class="nv">vector</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">index</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">str</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">str_len
</span>);
</code></pre></div></div>

#### Parameters

---
* `vector`

The vector to alter
* `index`

The row position in the vector to assign the string to
* `str`

The string
* `str_len`

The length of the string (in bytes)

<br>


### `duckdb_list_vector_get_child`

---
Retrieves the child vector of a list vector.

The resulting vector is valid as long as the parent vector is valid.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_vector</span> <span class="nv">duckdb_list_vector_get_child</span>(<span class="nv">
</span>  <span class="kt">duckdb_vector</span> <span class="nv">vector
</span>);
</code></pre></div></div>

#### Parameters

---
* `vector`

The vector
* `returns`

The child vector

<br>


### `duckdb_list_vector_get_size`

---
Returns the size of the child vector of the list

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">idx_t</span> <span class="nv">duckdb_list_vector_get_size</span>(<span class="nv">
</span>  <span class="kt">duckdb_vector</span> <span class="nv">vector
</span>);
</code></pre></div></div>

#### Parameters

---
* `vector`

The vector
* `returns`

The size of the child list

<br>


### `duckdb_list_vector_set_size`

---
Sets the total size of the underlying child-vector of a list vector.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_list_vector_set_size</span>(<span class="nv">
</span>  <span class="kt">duckdb_vector</span> <span class="nv">vector</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">size
</span>);
</code></pre></div></div>

#### Parameters

---
* `vector`

The list vector.
* `size`

The size of the child list.
* `returns`

The duckdb state. Returns DuckDBError if the vector is nullptr.

<br>


### `duckdb_list_vector_reserve`

---
Sets the total capacity of the underlying child-vector of a list.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_list_vector_reserve</span>(<span class="nv">
</span>  <span class="kt">duckdb_vector</span> <span class="nv">vector</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">required_capacity
</span>);
</code></pre></div></div>

#### Parameters

---
* `vector`

The list vector.
* `required_capacity`

the total capacity to reserve.
* `return`

The duckdb state. Returns DuckDBError if the vector is nullptr.

<br>


### `duckdb_struct_vector_get_child`

---
Retrieves the child vector of a struct vector.

The resulting vector is valid as long as the parent vector is valid.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_vector</span> <span class="nv">duckdb_struct_vector_get_child</span>(<span class="nv">
</span>  <span class="kt">duckdb_vector</span> <span class="nv">vector</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">index
</span>);
</code></pre></div></div>

#### Parameters

---
* `vector`

The vector
* `index`

The child index
* `returns`

The child vector

<br>


### `duckdb_validity_row_is_valid`

---
Returns whether or not a row is valid (i.e., not NULL) in the given validity mask.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nv">duckdb_validity_row_is_valid</span>(<span class="nv">
</span>  <span class="kt">uint64_t</span> *<span class="nv">validity</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">row
</span>);
</code></pre></div></div>

#### Parameters

---
* `validity`

The validity mask, as obtained through `duckdb_vector_get_validity`
* `row`

The row index
* `returns`

true if the row is valid, false otherwise

<br>


### `duckdb_validity_set_row_validity`

---
In a validity mask, sets a specific row to either valid or invalid.

Note that `duckdb_vector_ensure_validity_writable` should be called before calling `duckdb_vector_get_validity`,
to ensure that there is a validity mask to write to.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_validity_set_row_validity</span>(<span class="nv">
</span>  <span class="kt">uint64_t</span> *<span class="nv">validity</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">row</span>,<span class="nv">
</span>  <span class="kt">bool</span> <span class="nv">valid
</span>);
</code></pre></div></div>

#### Parameters

---
* `validity`

The validity mask, as obtained through `duckdb_vector_get_validity`.
* `row`

The row index
* `valid`

Whether or not to set the row to valid, or invalid

<br>


### `duckdb_validity_set_row_invalid`

---
In a validity mask, sets a specific row to invalid.

Equivalent to `duckdb_validity_set_row_validity` with valid set to false.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_validity_set_row_invalid</span>(<span class="nv">
</span>  <span class="kt">uint64_t</span> *<span class="nv">validity</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">row
</span>);
</code></pre></div></div>

#### Parameters

---
* `validity`

The validity mask
* `row`

The row index

<br>


### `duckdb_validity_set_row_valid`

---
In a validity mask, sets a specific row to valid.

Equivalent to `duckdb_validity_set_row_validity` with valid set to true.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_validity_set_row_valid</span>(<span class="nv">
</span>  <span class="kt">uint64_t</span> *<span class="nv">validity</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">row
</span>);
</code></pre></div></div>

#### Parameters

---
* `validity`

The validity mask
* `row`

The row index

<br>


### `duckdb_create_table_function`

---
Creates a new empty table function.

The return value should be destroyed with `duckdb_destroy_table_function`.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_table_function</span> <span class="nv">duckdb_create_table_function</span>(<span class="nv">
</span>  <span class="nv">
</span>);
</code></pre></div></div>

#### Parameters

---
* `returns`

The table function object.

<br>


### `duckdb_destroy_table_function`

---
Destroys the given table function object.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_destroy_table_function</span>(<span class="nv">
</span>  <span class="kt">duckdb_table_function</span> *<span class="nv">table_function
</span>);
</code></pre></div></div>

#### Parameters

---
* `table_function`

The table function to destroy

<br>


### `duckdb_table_function_set_name`

---
Sets the name of the given table function.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_table_function_set_name</span>(<span class="nv">
</span>  <span class="kt">duckdb_table_function</span> <span class="nv">table_function</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">name
</span>);
</code></pre></div></div>

#### Parameters

---
* `table_function`

The table function
* `name`

The name of the table function

<br>


### `duckdb_table_function_add_parameter`

---
Adds a parameter to the table function.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_table_function_add_parameter</span>(<span class="nv">
</span>  <span class="kt">duckdb_table_function</span> <span class="nv">table_function</span>,<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> <span class="nv">type
</span>);
</code></pre></div></div>

#### Parameters

---
* `table_function`

The table function
* `type`

The type of the parameter to add.

<br>


### `duckdb_table_function_add_named_parameter`

---
Adds a named parameter to the table function.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_table_function_add_named_parameter</span>(<span class="nv">
</span>  <span class="kt">duckdb_table_function</span> <span class="nv">table_function</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">name</span>,<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> <span class="nv">type
</span>);
</code></pre></div></div>

#### Parameters

---
* `table_function`

The table function
* `name`

The name of the parameter
* `type`

The type of the parameter to add.

<br>


### `duckdb_table_function_set_extra_info`

---
Assigns extra information to the table function that can be fetched during binding, etc.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_table_function_set_extra_info</span>(<span class="nv">
</span>  <span class="kt">duckdb_table_function</span> <span class="nv">table_function</span>,<span class="nv">
</span>  <span class="kt">void</span> *<span class="nv">extra_info</span>,<span class="nv">
</span>  <span class="nv">duckdb_delete_callback_t</span> <span class="nv">destroy
</span>);
</code></pre></div></div>

#### Parameters

---
* `table_function`

The table function
* `extra_info`

The extra information
* `destroy`

The callback that will be called to destroy the bind data (if any)

<br>


### `duckdb_table_function_set_bind`

---
Sets the bind function of the table function

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_table_function_set_bind</span>(<span class="nv">
</span>  <span class="kt">duckdb_table_function</span> <span class="nv">table_function</span>,<span class="nv">
</span>  <span class="nv">duckdb_table_function_bind_t</span> <span class="nv">bind
</span>);
</code></pre></div></div>

#### Parameters

---
* `table_function`

The table function
* `bind`

The bind function

<br>


### `duckdb_table_function_set_init`

---
Sets the init function of the table function

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_table_function_set_init</span>(<span class="nv">
</span>  <span class="kt">duckdb_table_function</span> <span class="nv">table_function</span>,<span class="nv">
</span>  <span class="nv">duckdb_table_function_init_t</span> <span class="nv">init
</span>);
</code></pre></div></div>

#### Parameters

---
* `table_function`

The table function
* `init`

The init function

<br>


### `duckdb_table_function_set_local_init`

---
Sets the thread-local init function of the table function

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_table_function_set_local_init</span>(<span class="nv">
</span>  <span class="kt">duckdb_table_function</span> <span class="nv">table_function</span>,<span class="nv">
</span>  <span class="nv">duckdb_table_function_init_t</span> <span class="nv">init
</span>);
</code></pre></div></div>

#### Parameters

---
* `table_function`

The table function
* `init`

The init function

<br>


### `duckdb_table_function_set_function`

---
Sets the main function of the table function

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_table_function_set_function</span>(<span class="nv">
</span>  <span class="kt">duckdb_table_function</span> <span class="nv">table_function</span>,<span class="nv">
</span>  <span class="nv">duckdb_table_function_t</span> <span class="nv">function
</span>);
</code></pre></div></div>

#### Parameters

---
* `table_function`

The table function
* `function`

The function

<br>


### `duckdb_table_function_supports_projection_pushdown`

---
Sets whether or not the given table function supports projection pushdown.

If this is set to true, the system will provide a list of all required columns in the `init` stage through
the `duckdb_init_get_column_count` and `duckdb_init_get_column_index` functions.
If this is set to false (the default), the system will expect all columns to be projected.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_table_function_supports_projection_pushdown</span>(<span class="nv">
</span>  <span class="kt">duckdb_table_function</span> <span class="nv">table_function</span>,<span class="nv">
</span>  <span class="kt">bool</span> <span class="nv">pushdown
</span>);
</code></pre></div></div>

#### Parameters

---
* `table_function`

The table function
* `pushdown`

True if the table function supports projection pushdown, false otherwise.

<br>


### `duckdb_register_table_function`

---
Register the table function object within the given connection.

The function requires at least a name, a bind function, an init function and a main function.

If the function is incomplete or a function with this name already exists DuckDBError is returned.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_register_table_function</span>(<span class="nv">
</span>  <span class="kt">duckdb_connection</span> <span class="nv">con</span>,<span class="nv">
</span>  <span class="kt">duckdb_table_function</span> <span class="nv">function
</span>);
</code></pre></div></div>

#### Parameters

---
* `con`

The connection to register it in.
* `function`

The function pointer
* `returns`

Whether or not the registration was successful.

<br>


### `duckdb_bind_get_extra_info`

---
Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> *<span class="nv">duckdb_bind_get_extra_info</span>(<span class="nv">
</span>  <span class="kt">duckdb_bind_info</span> <span class="nv">info
</span>);
</code></pre></div></div>

#### Parameters

---
* `info`

The info object
* `returns`

The extra info

<br>


### `duckdb_bind_add_result_column`

---
Adds a result column to the output of the table function.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_bind_add_result_column</span>(<span class="nv">
</span>  <span class="kt">duckdb_bind_info</span> <span class="nv">info</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">name</span>,<span class="nv">
</span>  <span class="kt">duckdb_logical_type</span> <span class="nv">type
</span>);
</code></pre></div></div>

#### Parameters

---
* `info`

The info object
* `name`

The name of the column
* `type`

The logical type of the column

<br>


### `duckdb_bind_get_parameter_count`

---
Retrieves the number of regular (non-named) parameters to the function.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">idx_t</span> <span class="nv">duckdb_bind_get_parameter_count</span>(<span class="nv">
</span>  <span class="kt">duckdb_bind_info</span> <span class="nv">info
</span>);
</code></pre></div></div>

#### Parameters

---
* `info`

The info object
* `returns`

The number of parameters

<br>


### `duckdb_bind_get_parameter`

---
Retrieves the parameter at the given index.

The result must be destroyed with `duckdb_destroy_value`.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_value</span> <span class="nv">duckdb_bind_get_parameter</span>(<span class="nv">
</span>  <span class="kt">duckdb_bind_info</span> <span class="nv">info</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">index
</span>);
</code></pre></div></div>

#### Parameters

---
* `info`

The info object
* `index`

The index of the parameter to get
* `returns`

The value of the parameter. Must be destroyed with `duckdb_destroy_value`.

<br>


### `duckdb_bind_get_named_parameter`

---
Retrieves a named parameter with the given name.

The result must be destroyed with `duckdb_destroy_value`.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_value</span> <span class="nv">duckdb_bind_get_named_parameter</span>(<span class="nv">
</span>  <span class="kt">duckdb_bind_info</span> <span class="nv">info</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">name
</span>);
</code></pre></div></div>

#### Parameters

---
* `info`

The info object
* `name`

The name of the parameter
* `returns`

The value of the parameter. Must be destroyed with `duckdb_destroy_value`.

<br>


### `duckdb_bind_set_bind_data`

---
Sets the user-provided bind data in the bind object. This object can be retrieved again during execution.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_bind_set_bind_data</span>(<span class="nv">
</span>  <span class="kt">duckdb_bind_info</span> <span class="nv">info</span>,<span class="nv">
</span>  <span class="kt">void</span> *<span class="nv">bind_data</span>,<span class="nv">
</span>  <span class="nv">duckdb_delete_callback_t</span> <span class="nv">destroy
</span>);
</code></pre></div></div>

#### Parameters

---
* `info`

The info object
* `extra_data`

The bind data object.
* `destroy`

The callback that will be called to destroy the bind data (if any)

<br>


### `duckdb_bind_set_cardinality`

---
Sets the cardinality estimate for the table function, used for optimization.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_bind_set_cardinality</span>(<span class="nv">
</span>  <span class="kt">duckdb_bind_info</span> <span class="nv">info</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">cardinality</span>,<span class="nv">
</span>  <span class="kt">bool</span> <span class="nv">is_exact
</span>);
</code></pre></div></div>

#### Parameters

---
* `info`

The bind data object.
* `is_exact`

Whether or not the cardinality estimate is exact, or an approximation

<br>


### `duckdb_bind_set_error`

---
Report that an error has occurred while calling bind.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_bind_set_error</span>(<span class="nv">
</span>  <span class="kt">duckdb_bind_info</span> <span class="nv">info</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">error
</span>);
</code></pre></div></div>

#### Parameters

---
* `info`

The info object
* `error`

The error message

<br>


### `duckdb_init_get_extra_info`

---
Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> *<span class="nv">duckdb_init_get_extra_info</span>(<span class="nv">
</span>  <span class="kt">duckdb_init_info</span> <span class="nv">info
</span>);
</code></pre></div></div>

#### Parameters

---
* `info`

The info object
* `returns`

The extra info

<br>


### `duckdb_init_get_bind_data`

---
Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.

Note that the bind data should be considered as read-only.
For tracking state, use the init data instead.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> *<span class="nv">duckdb_init_get_bind_data</span>(<span class="nv">
</span>  <span class="kt">duckdb_init_info</span> <span class="nv">info
</span>);
</code></pre></div></div>

#### Parameters

---
* `info`

The info object
* `returns`

The bind data object

<br>


### `duckdb_init_set_init_data`

---
Sets the user-provided init data in the init object. This object can be retrieved again during execution.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_init_set_init_data</span>(<span class="nv">
</span>  <span class="kt">duckdb_init_info</span> <span class="nv">info</span>,<span class="nv">
</span>  <span class="kt">void</span> *<span class="nv">init_data</span>,<span class="nv">
</span>  <span class="nv">duckdb_delete_callback_t</span> <span class="nv">destroy
</span>);
</code></pre></div></div>

#### Parameters

---
* `info`

The info object
* `extra_data`

The init data object.
* `destroy`

The callback that will be called to destroy the init data (if any)

<br>


### `duckdb_init_get_column_count`

---
Returns the number of projected columns.

This function must be used if projection pushdown is enabled to figure out which columns to emit.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">idx_t</span> <span class="nv">duckdb_init_get_column_count</span>(<span class="nv">
</span>  <span class="kt">duckdb_init_info</span> <span class="nv">info
</span>);
</code></pre></div></div>

#### Parameters

---
* `info`

The info object
* `returns`

The number of projected columns.

<br>


### `duckdb_init_get_column_index`

---
Returns the column index of the projected column at the specified position.

This function must be used if projection pushdown is enabled to figure out which columns to emit.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">idx_t</span> <span class="nv">duckdb_init_get_column_index</span>(<span class="nv">
</span>  <span class="kt">duckdb_init_info</span> <span class="nv">info</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">column_index
</span>);
</code></pre></div></div>

#### Parameters

---
* `info`

The info object
* `column_index`

The index at which to get the projected column index, from 0..duckdb_init_get_column_count(info)
* `returns`

The column index of the projected column.

<br>


### `duckdb_init_set_max_threads`

---
Sets how many threads can process this table function in parallel (default: 1)

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_init_set_max_threads</span>(<span class="nv">
</span>  <span class="kt">duckdb_init_info</span> <span class="nv">info</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">max_threads
</span>);
</code></pre></div></div>

#### Parameters

---
* `info`

The info object
* `max_threads`

The maximum amount of threads that can process this table function

<br>


### `duckdb_init_set_error`

---
Report that an error has occurred while calling init.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_init_set_error</span>(<span class="nv">
</span>  <span class="kt">duckdb_init_info</span> <span class="nv">info</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">error
</span>);
</code></pre></div></div>

#### Parameters

---
* `info`

The info object
* `error`

The error message

<br>


### `duckdb_function_get_extra_info`

---
Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> *<span class="nv">duckdb_function_get_extra_info</span>(<span class="nv">
</span>  <span class="kt">duckdb_function_info</span> <span class="nv">info
</span>);
</code></pre></div></div>

#### Parameters

---
* `info`

The info object
* `returns`

The extra info

<br>


### `duckdb_function_get_bind_data`

---
Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.

Note that the bind data should be considered as read-only.
For tracking state, use the init data instead.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> *<span class="nv">duckdb_function_get_bind_data</span>(<span class="nv">
</span>  <span class="kt">duckdb_function_info</span> <span class="nv">info
</span>);
</code></pre></div></div>

#### Parameters

---
* `info`

The info object
* `returns`

The bind data object

<br>


### `duckdb_function_get_init_data`

---
Gets the init data set by `duckdb_init_set_init_data` during the init.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> *<span class="nv">duckdb_function_get_init_data</span>(<span class="nv">
</span>  <span class="kt">duckdb_function_info</span> <span class="nv">info
</span>);
</code></pre></div></div>

#### Parameters

---
* `info`

The info object
* `returns`

The init data object

<br>


### `duckdb_function_get_local_init_data`

---
Gets the thread-local init data set by `duckdb_init_set_init_data` during the local_init.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> *<span class="nv">duckdb_function_get_local_init_data</span>(<span class="nv">
</span>  <span class="kt">duckdb_function_info</span> <span class="nv">info
</span>);
</code></pre></div></div>

#### Parameters

---
* `info`

The info object
* `returns`

The init data object

<br>


### `duckdb_function_set_error`

---
Report that an error has occurred while executing the function.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_function_set_error</span>(<span class="nv">
</span>  <span class="kt">duckdb_function_info</span> <span class="nv">info</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">error
</span>);
</code></pre></div></div>

#### Parameters

---
* `info`

The info object
* `error`

The error message

<br>


### `duckdb_add_replacement_scan`

---
Add a replacement scan definition to the specified database

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_add_replacement_scan</span>(<span class="nv">
</span>  <span class="kt">duckdb_database</span> <span class="nv">db</span>,<span class="nv">
</span>  <span class="nv">duckdb_replacement_callback_t</span> <span class="nv">replacement</span>,<span class="nv">
</span>  <span class="kt">void</span> *<span class="nv">extra_data</span>,<span class="nv">
</span>  <span class="nv">duckdb_delete_callback_t</span> <span class="nv">delete_callback
</span>);
</code></pre></div></div>

#### Parameters

---
* `db`

The database object to add the replacement scan to
* `replacement`

The replacement scan callback
* `extra_data`

Extra data that is passed back into the specified callback
* `delete_callback`

The delete callback to call on the extra data, if any

<br>


### `duckdb_replacement_scan_set_function_name`

---
Sets the replacement function name to use. If this function is called in the replacement callback,
the replacement scan is performed. If it is not called, the replacement callback is not performed.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_replacement_scan_set_function_name</span>(<span class="nv">
</span>  <span class="kt">duckdb_replacement_scan_info</span> <span class="nv">info</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">function_name
</span>);
</code></pre></div></div>

#### Parameters

---
* `info`

The info object
* `function_name`

The function name to substitute.

<br>


### `duckdb_replacement_scan_add_parameter`

---
Adds a parameter to the replacement scan function.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_replacement_scan_add_parameter</span>(<span class="nv">
</span>  <span class="kt">duckdb_replacement_scan_info</span> <span class="nv">info</span>,<span class="nv">
</span>  <span class="kt">duckdb_value</span> <span class="nv">parameter
</span>);
</code></pre></div></div>

#### Parameters

---
* `info`

The info object
* `parameter`

The parameter to add.

<br>


### `duckdb_replacement_scan_set_error`

---
Report that an error has occurred while executing the replacement scan.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_replacement_scan_set_error</span>(<span class="nv">
</span>  <span class="kt">duckdb_replacement_scan_info</span> <span class="nv">info</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">error
</span>);
</code></pre></div></div>

#### Parameters

---
* `info`

The info object
* `error`

The error message

<br>


### `duckdb_appender_create`

---
Creates an appender object.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_appender_create</span>(<span class="nv">
</span>  <span class="kt">duckdb_connection</span> <span class="nv">connection</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">schema</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">table</span>,<span class="nv">
</span>  <span class="kt">duckdb_appender</span> *<span class="nv">out_appender
</span>);
</code></pre></div></div>

#### Parameters

---
* `connection`

The connection context to create the appender in.
* `schema`

The schema of the table to append to, or `nullptr` for the default schema.
* `table`

The table name to append to.
* `out_appender`

The resulting appender object.
* `returns`

`DuckDBSuccess` on success or `DuckDBError` on failure.

<br>


### `duckdb_appender_error`

---
Returns the error message associated with the given appender.
If the appender has no error message, this returns `nullptr` instead.

The error message should not be freed. It will be de-allocated when `duckdb_appender_destroy` is called.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">const</span> <span class="kt">char</span> *<span class="nv">duckdb_appender_error</span>(<span class="nv">
</span>  <span class="kt">duckdb_appender</span> <span class="nv">appender
</span>);
</code></pre></div></div>

#### Parameters

---
* `appender`

The appender to get the error from.
* `returns`

The error message, or `nullptr` if there is none.

<br>


### `duckdb_appender_flush`

---
Flush the appender to the table, forcing the cache of the appender to be cleared and the data to be appended to the
base table.

This should generally not be used unless you know what you are doing. Instead, call `duckdb_appender_destroy` when you
are done with the appender.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_appender_flush</span>(<span class="nv">
</span>  <span class="kt">duckdb_appender</span> <span class="nv">appender
</span>);
</code></pre></div></div>

#### Parameters

---
* `appender`

The appender to flush.
* `returns`

`DuckDBSuccess` on success or `DuckDBError` on failure.

<br>


### `duckdb_appender_close`

---
Close the appender, flushing all intermediate state in the appender to the table and closing it for further appends.

This is generally not necessary. Call `duckdb_appender_destroy` instead.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_appender_close</span>(<span class="nv">
</span>  <span class="kt">duckdb_appender</span> <span class="nv">appender
</span>);
</code></pre></div></div>

#### Parameters

---
* `appender`

The appender to flush and close.
* `returns`

`DuckDBSuccess` on success or `DuckDBError` on failure.

<br>


### `duckdb_appender_destroy`

---
Close the appender and destroy it. Flushing all intermediate state in the appender to the table, and de-allocating
all memory associated with the appender.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_appender_destroy</span>(<span class="nv">
</span>  <span class="kt">duckdb_appender</span> *<span class="nv">appender
</span>);
</code></pre></div></div>

#### Parameters

---
* `appender`

The appender to flush, close and destroy.
* `returns`

`DuckDBSuccess` on success or `DuckDBError` on failure.

<br>


### `duckdb_appender_begin_row`

---
A nop function, provided for backwards compatibility reasons. Does nothing. Only `duckdb_appender_end_row` is required.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_appender_begin_row</span>(<span class="nv">
</span>  <span class="kt">duckdb_appender</span> <span class="nv">appender
</span>);
</code></pre></div></div>
<br>


### `duckdb_appender_end_row`

---
Finish the current row of appends. After end_row is called, the next row can be appended.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_appender_end_row</span>(<span class="nv">
</span>  <span class="kt">duckdb_appender</span> <span class="nv">appender
</span>);
</code></pre></div></div>

#### Parameters

---
* `appender`

The appender.
* `returns`

`DuckDBSuccess` on success or `DuckDBError` on failure.

<br>


### `duckdb_append_bool`

---
Append a bool value to the appender.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_append_bool</span>(<span class="nv">
</span>  <span class="kt">duckdb_appender</span> <span class="nv">appender</span>,<span class="nv">
</span>  <span class="kt">bool</span> <span class="nv">value
</span>);
</code></pre></div></div>
<br>


### `duckdb_append_int8`

---
Append an int8_t value to the appender.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_append_int8</span>(<span class="nv">
</span>  <span class="kt">duckdb_appender</span> <span class="nv">appender</span>,<span class="nv">
</span>  <span class="kt">int8_t</span> <span class="nv">value
</span>);
</code></pre></div></div>
<br>


### `duckdb_append_int16`

---
Append an int16_t value to the appender.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_append_int16</span>(<span class="nv">
</span>  <span class="kt">duckdb_appender</span> <span class="nv">appender</span>,<span class="nv">
</span>  <span class="kt">int16_t</span> <span class="nv">value
</span>);
</code></pre></div></div>
<br>


### `duckdb_append_int32`

---
Append an int32_t value to the appender.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_append_int32</span>(<span class="nv">
</span>  <span class="kt">duckdb_appender</span> <span class="nv">appender</span>,<span class="nv">
</span>  <span class="kt">int32_t</span> <span class="nv">value
</span>);
</code></pre></div></div>
<br>


### `duckdb_append_int64`

---
Append an int64_t value to the appender.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_append_int64</span>(<span class="nv">
</span>  <span class="kt">duckdb_appender</span> <span class="nv">appender</span>,<span class="nv">
</span>  <span class="kt">int64_t</span> <span class="nv">value
</span>);
</code></pre></div></div>
<br>


### `duckdb_append_hugeint`

---
Append a duckdb_hugeint value to the appender.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_append_hugeint</span>(<span class="nv">
</span>  <span class="kt">duckdb_appender</span> <span class="nv">appender</span>,<span class="nv">
</span>  <span class="kt">duckdb_hugeint</span> <span class="nv">value
</span>);
</code></pre></div></div>
<br>


### `duckdb_append_uint8`

---
Append a uint8_t value to the appender.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_append_uint8</span>(<span class="nv">
</span>  <span class="kt">duckdb_appender</span> <span class="nv">appender</span>,<span class="nv">
</span>  <span class="kt">uint8_t</span> <span class="nv">value
</span>);
</code></pre></div></div>
<br>


### `duckdb_append_uint16`

---
Append a uint16_t value to the appender.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_append_uint16</span>(<span class="nv">
</span>  <span class="kt">duckdb_appender</span> <span class="nv">appender</span>,<span class="nv">
</span>  <span class="kt">uint16_t</span> <span class="nv">value
</span>);
</code></pre></div></div>
<br>


### `duckdb_append_uint32`

---
Append a uint32_t value to the appender.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_append_uint32</span>(<span class="nv">
</span>  <span class="kt">duckdb_appender</span> <span class="nv">appender</span>,<span class="nv">
</span>  <span class="kt">uint32_t</span> <span class="nv">value
</span>);
</code></pre></div></div>
<br>


### `duckdb_append_uint64`

---
Append a uint64_t value to the appender.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_append_uint64</span>(<span class="nv">
</span>  <span class="kt">duckdb_appender</span> <span class="nv">appender</span>,<span class="nv">
</span>  <span class="kt">uint64_t</span> <span class="nv">value
</span>);
</code></pre></div></div>
<br>


### `duckdb_append_uhugeint`

---
Append a duckdb_uhugeint value to the appender.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_append_uhugeint</span>(<span class="nv">
</span>  <span class="kt">duckdb_appender</span> <span class="nv">appender</span>,<span class="nv">
</span>  <span class="nv">duckdb_uhugeint</span> <span class="nv">value
</span>);
</code></pre></div></div>
<br>


### `duckdb_append_float`

---
Append a float value to the appender.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_append_float</span>(<span class="nv">
</span>  <span class="kt">duckdb_appender</span> <span class="nv">appender</span>,<span class="nv">
</span>  <span class="kt">float</span> <span class="nv">value
</span>);
</code></pre></div></div>
<br>


### `duckdb_append_double`

---
Append a double value to the appender.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_append_double</span>(<span class="nv">
</span>  <span class="kt">duckdb_appender</span> <span class="nv">appender</span>,<span class="nv">
</span>  <span class="kt">double</span> <span class="nv">value
</span>);
</code></pre></div></div>
<br>


### `duckdb_append_date`

---
Append a duckdb_date value to the appender.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_append_date</span>(<span class="nv">
</span>  <span class="kt">duckdb_appender</span> <span class="nv">appender</span>,<span class="nv">
</span>  <span class="kt">duckdb_date</span> <span class="nv">value
</span>);
</code></pre></div></div>
<br>


### `duckdb_append_time`

---
Append a duckdb_time value to the appender.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_append_time</span>(<span class="nv">
</span>  <span class="kt">duckdb_appender</span> <span class="nv">appender</span>,<span class="nv">
</span>  <span class="kt">duckdb_time</span> <span class="nv">value
</span>);
</code></pre></div></div>
<br>


### `duckdb_append_timestamp`

---
Append a duckdb_timestamp value to the appender.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_append_timestamp</span>(<span class="nv">
</span>  <span class="kt">duckdb_appender</span> <span class="nv">appender</span>,<span class="nv">
</span>  <span class="kt">duckdb_timestamp</span> <span class="nv">value
</span>);
</code></pre></div></div>
<br>


### `duckdb_append_interval`

---
Append a duckdb_interval value to the appender.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_append_interval</span>(<span class="nv">
</span>  <span class="kt">duckdb_appender</span> <span class="nv">appender</span>,<span class="nv">
</span>  <span class="kt">duckdb_interval</span> <span class="nv">value
</span>);
</code></pre></div></div>
<br>


### `duckdb_append_varchar`

---
Append a varchar value to the appender.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_append_varchar</span>(<span class="nv">
</span>  <span class="kt">duckdb_appender</span> <span class="nv">appender</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">val
</span>);
</code></pre></div></div>
<br>


### `duckdb_append_varchar_length`

---
Append a varchar value to the appender.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_append_varchar_length</span>(<span class="nv">
</span>  <span class="kt">duckdb_appender</span> <span class="nv">appender</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">val</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">length
</span>);
</code></pre></div></div>
<br>


### `duckdb_append_blob`

---
Append a blob value to the appender.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_append_blob</span>(<span class="nv">
</span>  <span class="kt">duckdb_appender</span> <span class="nv">appender</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">void</span> *<span class="nv">data</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">length
</span>);
</code></pre></div></div>
<br>


### `duckdb_append_null`

---
Append a NULL value to the appender (of any type).

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_append_null</span>(<span class="nv">
</span>  <span class="kt">duckdb_appender</span> <span class="nv">appender
</span>);
</code></pre></div></div>
<br>


### `duckdb_append_data_chunk`

---
Appends a pre-filled data chunk to the specified appender.

The types of the data chunk must exactly match the types of the table, no casting is performed.
If the types do not match or the appender is in an invalid state, DuckDBError is returned.
If the append is successful, DuckDBSuccess is returned.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_append_data_chunk</span>(<span class="nv">
</span>  <span class="kt">duckdb_appender</span> <span class="nv">appender</span>,<span class="nv">
</span>  <span class="kt">duckdb_data_chunk</span> <span class="nv">chunk
</span>);
</code></pre></div></div>

#### Parameters

---
* `appender`

The appender to append to.
* `chunk`

The data chunk to append.
* `returns`

The return state.

<br>


### `duckdb_query_arrow`

---
Executes a SQL query within a connection and stores the full (materialized) result in an arrow structure.
If the query fails to execute, DuckDBError is returned and the error message can be retrieved by calling
`duckdb_query_arrow_error`.

Note that after running `duckdb_query_arrow`, `duckdb_destroy_arrow` must be called on the result object even if the
query fails, otherwise the error stored within the result will not be freed correctly.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_query_arrow</span>(<span class="nv">
</span>  <span class="kt">duckdb_connection</span> <span class="nv">connection</span>,<span class="nv">
</span>  <span class="kt">const</span> <span class="kt">char</span> *<span class="nv">query</span>,<span class="nv">
</span>  <span class="kt">duckdb_arrow</span> *<span class="nv">out_result
</span>);
</code></pre></div></div>

#### Parameters

---
* `connection`

The connection to perform the query in.
* `query`

The SQL query to run.
* `out_result`

The query result.
* `returns`

`DuckDBSuccess` on success or `DuckDBError` on failure.

<br>


### `duckdb_query_arrow_schema`

---
Fetch the internal arrow schema from the arrow result.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_query_arrow_schema</span>(<span class="nv">
</span>  <span class="kt">duckdb_arrow</span> <span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">duckdb_arrow_schema</span> *<span class="nv">out_schema
</span>);
</code></pre></div></div>

#### Parameters

---
* `result`

The result to fetch the schema from.
* `out_schema`

The output schema.
* `returns`

`DuckDBSuccess` on success or `DuckDBError` on failure.

<br>


### `duckdb_prepared_arrow_schema`

---
Fetch the internal arrow schema from the prepared statement.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_prepared_arrow_schema</span>(<span class="nv">
</span>  <span class="kt">duckdb_prepared_statement</span> <span class="nv">prepared</span>,<span class="nv">
</span>  <span class="kt">duckdb_arrow_schema</span> *<span class="nv">out_schema
</span>);
</code></pre></div></div>

#### Parameters

---
* `result`

The prepared statement to fetch the schema from.
* `out_schema`

The output schema.
* `returns`

`DuckDBSuccess` on success or `DuckDBError` on failure.

<br>


### `duckdb_result_arrow_array`

---
Convert a data chunk into an arrow struct array.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_result_arrow_array</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> <span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">duckdb_data_chunk</span> <span class="nv">chunk</span>,<span class="nv">
</span>  <span class="kt">duckdb_arrow_array</span> *<span class="nv">out_array
</span>);
</code></pre></div></div>

#### Parameters

---
* `result`

The result object the data chunk have been fetched from.
* `chunk`

The data chunk to convert.
* `out_array`

The output array.

<br>


### `duckdb_query_arrow_array`

---
Fetch an internal arrow struct array from the arrow result.

This function can be called multiple time to get next chunks, which will free the previous out_array.
So consume the out_array before calling this function again.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_state</span> <span class="nv">duckdb_query_arrow_array</span>(<span class="nv">
</span>  <span class="kt">duckdb_arrow</span> <span class="nv">result</span>,<span class="nv">
</span>  <span class="kt">duckdb_arrow_array</span> *<span class="nv">out_array
</span>);
</code></pre></div></div>

#### Parameters

---
* `result`

The result to fetch the array from.
* `out_array`

The output array.
* `returns`

`DuckDBSuccess` on success or `DuckDBError` on failure.

<br>


### `duckdb_arrow_column_count`

---
Returns the number of columns present in a the arrow result object.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">idx_t</span> <span class="nv">duckdb_arrow_column_count</span>(<span class="nv">
</span>  <span class="kt">duckdb_arrow</span> <span class="nv">result
</span>);
</code></pre></div></div>

#### Parameters

---
* `result`

The result object.
* `returns`

The number of columns present in the result object.

<br>


### `duckdb_arrow_row_count`

---
Returns the number of rows present in a the arrow result object.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">idx_t</span> <span class="nv">duckdb_arrow_row_count</span>(<span class="nv">
</span>  <span class="kt">duckdb_arrow</span> <span class="nv">result
</span>);
</code></pre></div></div>

#### Parameters

---
* `result`

The result object.
* `returns`

The number of rows present in the result object.

<br>


### `duckdb_arrow_rows_changed`

---
Returns the number of rows changed by the query stored in the arrow result. This is relevant only for
INSERT/UPDATE/DELETE queries. For other queries the rows_changed will be 0.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">idx_t</span> <span class="nv">duckdb_arrow_rows_changed</span>(<span class="nv">
</span>  <span class="kt">duckdb_arrow</span> <span class="nv">result
</span>);
</code></pre></div></div>

#### Parameters

---
* `result`

The result object.
* `returns`

The number of rows changed.

<br>


### `duckdb_query_arrow_error`

---
Returns the error message contained within the result. The error is only set if `duckdb_query_arrow` returns
`DuckDBError`.

The error message should not be freed. It will be de-allocated when `duckdb_destroy_arrow` is called.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">const</span> <span class="kt">char</span> *<span class="nv">duckdb_query_arrow_error</span>(<span class="nv">
</span>  <span class="kt">duckdb_arrow</span> <span class="nv">result
</span>);
</code></pre></div></div>

#### Parameters

---
* `result`

The result object to fetch the nullmask from.
* `returns`

The error of the result.

<br>


### `duckdb_destroy_arrow`

---
Closes the result and de-allocates all memory allocated for the arrow result.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_destroy_arrow</span>(<span class="nv">
</span>  <span class="kt">duckdb_arrow</span> *<span class="nv">result
</span>);
</code></pre></div></div>

#### Parameters

---
* `result`

The result to destroy.

<br>


### `duckdb_execute_tasks`

---
Execute DuckDB tasks on this thread.

Will return after `max_tasks` have been executed, or if there are no more tasks present.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_execute_tasks</span>(<span class="nv">
</span>  <span class="kt">duckdb_database</span> <span class="nv">database</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">max_tasks
</span>);
</code></pre></div></div>

#### Parameters

---
* `database`

The database object to execute tasks for
* `max_tasks`

The maximum amount of tasks to execute

<br>


### `duckdb_create_task_state`

---
Creates a task state that can be used with duckdb_execute_tasks_state to execute tasks until
duckdb_finish_execution is called on the state.

duckdb_destroy_state should be called on the result in order to free memory.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">duckdb_task_state</span> <span class="nv">duckdb_create_task_state</span>(<span class="nv">
</span>  <span class="kt">duckdb_database</span> <span class="nv">database
</span>);
</code></pre></div></div>

#### Parameters

---
* `database`

The database object to create the task state for
* `returns`

The task state that can be used with duckdb_execute_tasks_state.

<br>


### `duckdb_execute_tasks_state`

---
Execute DuckDB tasks on this thread.

The thread will keep on executing tasks forever, until duckdb_finish_execution is called on the state.
Multiple threads can share the same duckdb_task_state.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_execute_tasks_state</span>(<span class="nv">
</span>  <span class="nv">duckdb_task_state</span> <span class="nv">state
</span>);
</code></pre></div></div>

#### Parameters

---
* `state`

The task state of the executor

<br>


### `duckdb_execute_n_tasks_state`

---
Execute DuckDB tasks on this thread.

The thread will keep on executing tasks until either duckdb_finish_execution is called on the state,
max_tasks tasks have been executed or there are no more tasks to be executed.

Multiple threads can share the same duckdb_task_state.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">idx_t</span> <span class="nv">duckdb_execute_n_tasks_state</span>(<span class="nv">
</span>  <span class="nv">duckdb_task_state</span> <span class="nv">state</span>,<span class="nv">
</span>  <span class="kt">idx_t</span> <span class="nv">max_tasks
</span>);
</code></pre></div></div>

#### Parameters

---
* `state`

The task state of the executor
* `max_tasks`

The maximum amount of tasks to execute
* `returns`

The amount of tasks that have actually been executed

<br>


### `duckdb_finish_execution`

---
Finish execution on a specific task.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_finish_execution</span>(<span class="nv">
</span>  <span class="nv">duckdb_task_state</span> <span class="nv">state
</span>);
</code></pre></div></div>

#### Parameters

---
* `state`

The task state to finish execution

<br>


### `duckdb_task_state_is_finished`

---
Check if the provided duckdb_task_state has finished execution

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nv">duckdb_task_state_is_finished</span>(<span class="nv">
</span>  <span class="nv">duckdb_task_state</span> <span class="nv">state
</span>);
</code></pre></div></div>

#### Parameters

---
* `state`

The task state to inspect
* `returns`

Whether or not duckdb_finish_execution has been called on the task state

<br>


### `duckdb_destroy_task_state`

---
Destroys the task state returned from duckdb_create_task_state.

Note that this should not be called while there is an active duckdb_execute_tasks_state running
on the task state.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nv">duckdb_destroy_task_state</span>(<span class="nv">
</span>  <span class="nv">duckdb_task_state</span> <span class="nv">state
</span>);
</code></pre></div></div>

#### Parameters

---
* `state`

The task state to clean up

<br>


### `duckdb_execution_is_finished`

---
Returns true if execution of the current query is finished.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nv">duckdb_execution_is_finished</span>(<span class="nv">
</span>  <span class="kt">duckdb_connection</span> <span class="nv">con
</span>);
</code></pre></div></div>

#### Parameters

---
* `con`

The connection on which to check

<br>


### `duckdb_stream_fetch_chunk`

---
Fetches a data chunk from the (streaming) duckdb_result. This function should be called repeatedly until the result is
exhausted.

The result must be destroyed with `duckdb_destroy_data_chunk`.

This function can only be used on duckdb_results created with 'duckdb_pending_prepared_streaming'

If this function is used, none of the other result functions can be used and vice versa (i.e., this function cannot be
mixed with the legacy result functions or the materialized result functions).

It is not known beforehand how many chunks will be returned by this result.

#### Syntax

---
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">duckdb_data_chunk</span> <span class="nv">duckdb_stream_fetch_chunk</span>(<span class="nv">
</span>  <span class="kt">duckdb_result</span> <span class="nv">result
</span>);
</code></pre></div></div>

#### Parameters

---
* `result`

The result object to fetch the data chunk from.
* `returns`

The resulting data chunk. Returns `NULL` if the result has an error.

<br>

